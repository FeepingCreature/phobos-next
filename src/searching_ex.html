<html><head>
        <!-- Generated by Ddoc from /home/per/Work/justd/phobos-next/src/searching_ex.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>searching_ex</title>
        </head><body>
        <h1>searching_ex</h1>
Extensions to std.algorithm.searching.
<br><br>
<b>License:</b><br>
.
<br><br>
<b>Authors:</b><br>
<br><br>

<dl><dt><big><a name="binarySearch"></a>size_t <u>binarySearch</u>(R, E)(const R[] <i>values</i>, in E <i>value</i>) if (is(typeof(<i>values</i>[0].init == E.init)));
</big></dt>
<dd>This function returns the index of the <pre style="display:inline;" class="d_inline_code"><i>value</i></pre> if it exist among <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>,
    <pre style="display:inline;" class="d_inline_code">size_t.max</pre> otherwise.
<br><br>
TODO Should we extend to isRandomAccessRange support? In that case we don't
    get static array support by default.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>const</font> <font color=blue>int</font>[9] x = [1, 3, 5, 6, 8, 9, 10, 13, 15];
<font color=blue>assert</font>(x.<u>binarySearch</u>(0) == size_t.max);
<font color=blue>assert</font>(x.<u>binarySearch</u>(1) == 0);
<font color=blue>assert</font>(x.<u>binarySearch</u>(2) == size_t.max);
<font color=blue>assert</font>(x.<u>binarySearch</u>(3) == 1);
<font color=blue>assert</font>(x.<u>binarySearch</u>(4) == size_t.max);
<font color=blue>assert</font>(x.<u>binarySearch</u>(5) == 2);
<font color=blue>assert</font>(x.<u>binarySearch</u>(6) == 3);
<font color=blue>assert</font>(x.<u>binarySearch</u>(7) == size_t.max);
<font color=blue>assert</font>(x.<u>binarySearch</u>(8) == 4);
<font color=blue>assert</font>(x.<u>binarySearch</u>(9) == 5);
<font color=blue>assert</font>(x.<u>binarySearch</u>(10) == 6);
<font color=blue>assert</font>(x.<u>binarySearch</u>(11) == size_t.max);
<font color=blue>assert</font>(x.<u>binarySearch</u>(12) == size_t.max);
<font color=blue>assert</font>(x.<u>binarySearch</u>(13) == 7);
<font color=blue>assert</font>(x.<u>binarySearch</u>(14) == size_t.max);
<font color=blue>assert</font>(x.<u>binarySearch</u>(15) == 8);
</pre>
<br><br>
</dd>
<dt><big><a name="containsStoreIndex"></a>bool <u>containsStoreIndex</u>(SearchPolicy sp = SearchPolicy.binarySearch, R, V)(R <i>range</i>, V <i>value</i>, out size_t <i>index</i>) if (is(typeof(ElementType!R.init == V.init)) &amp;&amp; isInstanceOf!(SortedRange, R));
</big></dt>
<dd>Same as <pre style="display:inline;" class="d_inline_code"><i>range</i>.contains()</pre> but also outputs <pre style="display:inline;" class="d_inline_code"><i>index</i></pre> where last occurrence of
    <pre style="display:inline;" class="d_inline_code">key</pre> is either currently stored (if <pre style="display:inline;" class="d_inline_code">true</pre> is returned) or should be stored
    (if <pre style="display:inline;" class="d_inline_code">false</pre> is returned) in order to preserve sortedness of <pre style="display:inline;" class="d_inline_code"><i>range</i></pre>.
<br><br>
The elements of <pre style="display:inline;" class="d_inline_code"><i>range</i></pre> are assumed to be sorted in default (ascending)
    order.
<br><br>

    TODO Move to member of <pre style="display:inline;" class="d_inline_code">SortedRange</pre> either as a new name or as an
    <pre style="display:inline;" class="d_inline_code">contains</pre>-overload take an extra <pre style="display:inline;" class="d_inline_code"><i>index</i></pre> as argument.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>const</font> <font color=blue>int</font>[0] x;
size_t <i>index</i>;
<font color=blue>import</font> std.<i>range</i> : assumeSorted;
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(<font color=blue>int</font>.min, <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(-1,      <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(0,       <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(1,       <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(<font color=blue>int</font>.max, <i>index</i>) &amp;&amp; <i>index</i> == 0);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>const</font> <font color=blue>int</font>[2] x = [1, 3];
size_t <i>index</i>;
<font color=blue>import</font> std.<i>range</i> : assumeSorted;
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(<font color=blue>int</font>.min, <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(-1,      <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(0,       <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>( x[].assumeSorted.<u>containsStoreIndex</u>(1,       <i>index</i>) &amp;&amp; <i>index</i> == 0);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(2,       <i>index</i>) &amp;&amp; <i>index</i> == 1);
<font color=blue>assert</font>( x[].assumeSorted.<u>containsStoreIndex</u>(3,       <i>index</i>) &amp;&amp; <i>index</i> == 1);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(4,       <i>index</i>) &amp;&amp; <i>index</i> == 2);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(5,       <i>index</i>) &amp;&amp; <i>index</i> == 2);
<font color=blue>assert</font>(!x[].assumeSorted.<u>containsStoreIndex</u>(<font color=blue>int</font>.max, <i>index</i>) &amp;&amp; <i>index</i> == 2);
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Per Nordl√∂w 2016-.
</small>
        </body></html>
