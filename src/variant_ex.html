<html><head>
        <!-- Generated by Ddoc from variant_ex.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>variant_ex</title>
        </head><body>
        <h1>variant_ex</h1>
Lightweight versions of polymorphism packed inside one single
    word/pointer.
<br><br>
Most significant bits are used to store type information.
<br><br>

    These higher bits are normally unused on 64-bit systems (tested on
    Linux). 16 higher bits are, on Linux, either 1 (kernel-space) or 0 (user-space).
<br><br>

    See also: http://forum.dlang.org/post/sybuoliqhhefcovxjfjv@forum.dlang.org
<br><br>

    TODO Ask forum.dlang.org: Is it safe to assume that <pre style="display:inline;" class="d_inline_code">typeBits</pre> most significant bits of a
    pointer are zero? If not put them in least significant part.
<br><br>

    TODO What todo with the fact that the GC will fail to scan WordVariant?
    Can the GC be tweaked to mask out the type bits before scanning?
<br><br>

    TODO Enable support for <pre style="display:inline;" class="d_inline_code">is null</pre> instead of <pre style="display:inline;" class="d_inline_code">isNull</pre>?
<br><br>

    TODO Use <pre style="display:inline;" class="d_inline_code">enforce()</pre> instead of <pre style="display:inline;" class="d_inline_code">assert()</pre> in WordVariant:initialize()
<br><br>

    TODO Move to Phobos std.variant<br><br>

<dl><dt><big><a name="WordVariant"></a>struct <u>WordVariant</u>(Types...);
</big></dt>
<dd>A variant of <pre style="display:inline;" class="d_inline_code">Types</pre> packed into a word (<pre style="display:inline;" class="d_inline_code">size_t</pre>).
<br><br>
Suitable for use in tree-data containers, such as radix trees (tries), where
    hybrid value (sparsely packed sub-tree) and pointer (to dense sub-tree)
    packing of sub-nodes is needed.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.meta : AliasSeq;

<font color=blue>alias</font> SubType = <u>WordVariant</u>!(<font color=blue>byte</font>*, <font color=blue>short</font>*);
<font color=blue>alias</font> SuperType = <u>WordVariant</u>!(<font color=blue>bool</font>*, <font color=blue>byte</font>*, <font color=blue>short</font>*, <font color=blue>long</font>*);

<font color=blue>byte</font>* byteValue = <font color=blue>cast</font>(<font color=blue>byte</font>*)(0x11);
<font color=blue>short</font>* shortValue = <font color=blue>cast</font>(<font color=blue>short</font>*)(0x22);

SubType sub = byteValue;
<font color=blue>assert</font>(sub.typeIndex == 1);
<font color=blue>assert</font>(sub.peek!(<font color=blue>byte</font>*));
<font color=blue>assert</font>(*(sub.peek!(<font color=blue>byte</font>*)) == byteValue);

SuperType sup = sub;
<font color=blue>assert</font>(sup.typeIndex == 2);
<font color=blue>assert</font>(sup.peek!(<font color=blue>byte</font>*));
<font color=blue>assert</font>(*(sup.peek!(<font color=blue>byte</font>*)) == byteValue);

sub = shortValue;
<font color=blue>assert</font>(sub.typeIndex == 2);
<font color=blue>assert</font>(sub.peek!(<font color=blue>short</font>*));
<font color=blue>assert</font>(*(sub.peek!(<font color=blue>short</font>*)) == shortValue);

sup = sub;
<font color=blue>assert</font>(sup.typeIndex == 3);
<font color=blue>assert</font>(sup.peek!(<font color=blue>short</font>*));
<font color=blue>assert</font>(*(sup.peek!(<font color=blue>short</font>*)) == shortValue);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.meta : AliasSeq;

<font color=blue>alias</font> Types = AliasSeq!(<font color=blue>byte</font>*, <font color=blue>short</font>*, <font color=blue>int</font>*, <font color=blue>long</font>*,
                        <font color=blue>ubyte</font>*, <font color=blue>ushort</font>*, <font color=blue>uint</font>*, <font color=blue>ulong</font>*,
                        <font color=blue>float</font>*, <font color=blue>double</font>*, <font color=blue>real</font>*,
                        <font color=blue>char</font>*, <font color=blue>wchar</font>*, <font color=blue>dchar</font>*);

<font color=blue>alias</font> V = <u>WordVariant</u>!Types;
V v;

<font color=blue>try</font> { <font color=blue>assert</font>(v.toString == <font color=red>"null"</font>); } <font color=blue>catch</font> (Exception e) { }

<font color=blue>assert</font>(v.isNull);
v = <font color=blue>null</font>;
<font color=blue>assert</font>(v.isNull);
<font color=blue>assert</font>(!v);

<font color=blue>foreach</font> (Tp; Types)
{
    <font color=blue>alias</font> T = <font color=blue>typeof</font>(*Tp.init);

    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { T[] a; v = &amp;a; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { v.peek!(T[]*); }));

    <font color=green>// assignment from stack pointer
</font>    T a = 73;
    T a_ = 73;

    v = &amp;a;
    <font color=blue>assert</font>(v);
    <font color=blue>assert</font>(!v.isNull);
    <font color=blue>assert</font>(v.typeIndex != 0);
    <font color=blue>assert</font>(v.isOfType!Tp);

    <font color=blue>assert</font>(v == &amp;a);
    <font color=blue>assert</font>(v != &amp;a_);
    <font color=blue>assert</font>(v);

    <font color=blue>foreach</font> (Up; Types)
    {
        <font color=blue>alias</font> U = <font color=blue>typeof</font>(*Up.init);
        <font color=blue>static</font> <font color=blue>if</font> (<font color=blue>is</font>(T == U))
        {
            <font color=blue>assert</font>(v.peek!Up);
            <font color=blue>assert</font>(*(v.peek!Up) == &amp;a);
            <font color=blue>assert</font>(v.as!Up == &amp;a);
        }
        <font color=blue>else</font>
        {
            <font color=blue>assert</font>(!v.peek!Up);
        }
    }

    <font color=green>// assignment from heap pointer
</font>    T* b = <font color=blue>new</font> T;
    T* b_ = <font color=blue>new</font> T;
    *b = 73;
    *b_ = 73;
    v = b;
    <font color=blue>assert</font>(v == b);
    <font color=blue>assert</font>(v != b_);
    <font color=blue>assert</font>(v);
    <font color=blue>foreach</font> (Up; Types)
    {
        <font color=blue>alias</font> U = <font color=blue>typeof</font>(*Up.init);
        <font color=blue>static</font> <font color=blue>if</font> (<font color=blue>is</font>(T == U))
        {
            <font color=blue>assert</font>(v.peek!Up);
            <font color=blue>assert</font>(*(v.peek!Up) == b);
        }
        <font color=blue>else</font>
        {
            <font color=blue>assert</font>(!v.peek!Up);
        }
    }

}
</pre>
<br><br>
<dl><dt><big><a name="WordVariant.canStore"></a>enum auto <u>canStore</u>(T);
</big></dt>
<dd>Is <pre style="display:inline;" class="d_inline_code">true</pre> iff a <pre style="display:inline;" class="d_inline_code">T</pre> can be stored.<br><br>

</dd>
<dt><big><a name="WordVariant.this"></a>this(T)(T <i>value</i>) if (canStore!T);
<br>this(typeof(null) <i>value</i>);
</big></dt>
<dd>Construction from <pre style="display:inline;" class="d_inline_code"><i>value</i></pre>.<br><br>

</dd>
<dt><big><a name="WordVariant.this.2"></a>this(SubTypes...)(WordVariant!SubTypes <i>value</i>);
</big></dt>
<dd>Construction from sub-variant <pre style="display:inline;" class="d_inline_code"><i>value</i></pre>.<br><br>

</dd>
<dt><big><a name="WordVariant.opAssign"></a>ref auto <u>opAssign</u>(typeof(this) <i>value</i>);
<br>ref auto <u>opAssign</u>(T)(T <i>that</i>) if (canStore!T);
<br>ref auto <u>opAssign</u>(typeof(null) <i>that</i>);
</big></dt>
<dd>Assignment from <pre style="display:inline;" class="d_inline_code"><i>that</i></pre>.<br><br>

</dd>
<dt><big><a name="WordVariant.opAssign.2"></a>ref auto <u>opAssign</u>(SubTypes...)(WordVariant!SubTypes <i>value</i>);
</big></dt>
<dd>Assignment from sub-variant <pre style="display:inline;" class="d_inline_code"><i>value</i></pre>.<br><br>

</dd>
<dt><big><a name="WordVariant.typeIx"></a>const Ix <u>typeIx</u>();
</big></dt>
<dd>Get zero-offset index as <pre style="display:inline;" class="d_inline_code">Ix</pre> of current variant type.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="VariantPointerTo"></a>struct <u>VariantPointerTo</u>(Types...);
</big></dt>
<dd>A typed pointer to a variant of <pre style="display:inline;" class="d_inline_code">Types</pre>, packed into a word (<pre style="display:inline;" class="d_inline_code">size_t</pre>).
    See also: <pre style="display:inline;" class="d_inline_code">std.bitmanip.taggedPointer</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.meta : AliasSeq;

<font color=blue>alias</font> Types = AliasSeq!(<font color=blue>byte</font>, <font color=blue>short</font>, <font color=blue>int</font>, <font color=blue>long</font>,
                        <font color=blue>ubyte</font>, <font color=blue>ushort</font>, <font color=blue>uint</font>, <font color=blue>ulong</font>,
                        <font color=blue>float</font>, <font color=blue>double</font>, <font color=blue>real</font>,
                        <font color=blue>char</font>, <font color=blue>wchar</font>, <font color=blue>dchar</font>);

<font color=blue>alias</font> V = <u>VariantPointerTo</u>!Types;

V v;
<font color=blue>assert</font>(v.isNull);
v = <font color=blue>null</font>;
<font color=blue>assert</font>(v.isNull);
<font color=blue>assert</font>(!v);

<font color=blue>foreach</font> (T; Types)
{
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { T[] a; v = &amp;a; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { v.peek!(T[]*); }));

    <font color=green>// assignment from stack pointer
</font>    T a = 73;
    T a_ = 73;
    v = &amp;a;
    <font color=blue>assert</font>(v == &amp;a);
    <font color=blue>assert</font>(v != &amp;a_);
    <font color=blue>assert</font>(v);
    <font color=blue>foreach</font> (U; Types)
    {
        <font color=blue>static</font> <font color=blue>if</font> (<font color=blue>is</font>(T == U))
        {
            <font color=blue>assert</font>(v.peek!U);
            <font color=blue>assert</font>(*(v.peek!U) == a);
        }
        <font color=blue>else</font>
        {
            <font color=blue>assert</font>(!v.peek!U);
        }
    }

    <font color=green>// assignment from heap pointer
</font>    T* b = <font color=blue>new</font> T;
    T* b_ = <font color=blue>new</font> T;
    *b = 73;
    *b_ = 73;
    v = b;
    <font color=blue>assert</font>(v == b);
    <font color=blue>assert</font>(v != b_);
    <font color=blue>assert</font>(v);
    <font color=blue>foreach</font> (U; Types)
    {
        <font color=blue>static</font> <font color=blue>if</font> (<font color=blue>is</font>(T == U))
        {
            <font color=blue>assert</font>(v.peek!U);
            <font color=blue>assert</font>(*(v.peek!U) == *b);
        }
        <font color=blue>else</font>
        {
            <font color=blue>assert</font>(!v.peek!U);
        }
    }

}
</pre>
<br><br>
<dl><dt><big><a name="VariantPointerTo.canStorePointerTo"></a>enum auto <u>canStorePointerTo</u>(T);
</big></dt>
<dd>Is <pre style="display:inline;" class="d_inline_code">true</pre> iff a pointer to a <pre style="display:inline;" class="d_inline_code">T</pre> can be stored.<br><br>

</dd>
<dt><big><a name="VariantPointerTo.this"></a>this(T)(T* <i>value</i>) if (canStorePointerTo!T);
<br>this(typeof(null) <i>value</i>);
</big></dt>
<dd>Construction from <pre style="display:inline;" class="d_inline_code"><i>value</i></pre>.<br><br>

</dd>
<dt><big><a name="VariantPointerTo.opAssign"></a>ref auto <u>opAssign</u>(T)(T* <i>that</i>) if (canStorePointerTo!T);
<br>ref auto <u>opAssign</u>(typeof(null) <i>that</i>);
</big></dt>
<dd>Assignment from <pre style="display:inline;" class="d_inline_code"><i>that</i></pre>.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
