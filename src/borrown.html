<html><head>
        <!-- Generated by Ddoc from borrown.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>borrown</title>
        </head><body>
        <h1>borrown</h1>
Ownership and borrwoing รก lรก Rust.
<br><br>
TODO Move to typecons_ex.
<br><br>

    TODO Perhaps disable all checking (and unittests) in release mode (when
    debug is not active), but preserve overloads sliceRO and sliceWR. If not use
    <pre style="display:inline;" class="d_inline_code">enforce</pre> instead.
<br><br>

    TODO Implement and use trait <pre style="display:inline;" class="d_inline_code">hasUnsafeSlicing</pre>
<br><br>

    TODO Add WriteBorrowedPointer, ReadBorrowedPointer to wrap <pre style="display:inline;" class="d_inline_code">ptr</pre> access to Container
<br><br>

    TODO Is sliceWR and sliceRO good names?<br><br>

<dl><dt><big><a name="Owned"></a>struct <u>Owned</u>(Container) if (needsOwnership!Container);
</big></dt>
<dd>Return wrapper around container <pre style="display:inline;" class="d_inline_code">Container</pre> that can be safely sliced, by
    tracking number of read borrowed ranges and whether it's currently write
    borrowed.
<br><br>
    Only relevant when <pre style="display:inline;" class="d_inline_code">Container</pre> implements referenced access over
    - <pre style="display:inline;" class="d_inline_code">opSlice</pre> and
    - <pre style="display:inline;" class="d_inline_code">opIndex</pre>
<br><br>

    TODO Iterate and wrap all @unsafe accessors () and wrapped borrow
    checks for all modifying members of <pre style="display:inline;" class="d_inline_code">Container</pre>?<br><br>

<dl><dt><big><a name="Owned.Range"></a>alias <u>Range</u> = typeof(Container.init[]);
</big></dt>
<dd>Type of range of <pre style="display:inline;" class="d_inline_code">Container</pre>.<br><br>

</dd>
<dt><big><a name="Owned.move"></a>typeof(this) <u>move</u>();
</big></dt>
<dd>Move <pre style="display:inline;" class="d_inline_code">this</pre> into a returned r-value.<br><br>

</dd>
<dt><big><a name="Owned.move.2"></a>pure nothrow @nogc @safe void <u>move</u>(ref typeof(this) <i>dst</i>);
</big></dt>
<dd>Checked overload for <u>move</u>.<br><br>

</dd>
<dt><big><a name="Owned.sliceRO"></a>const @trusted ReadBorrowedSlice!(Range, Owned) <u>sliceRO</u>();
</big></dt>
<dd>Get full read-only slice.<br><br>

</dd>
<dt><big><a name="Owned.sliceRO.2"></a>const @trusted ReadBorrowedSlice!(Range, Owned) <u>sliceRO</u>(size_t <i>i</i>, size_t <i>j</i>);
</big></dt>
<dd>Get read-only slice in range <i>i</i> .. <i>j</i>.<br><br>

</dd>
<dt><big><a name="Owned.sliceWR"></a>@trusted WriteBorrowedSlice!(Range, Owned) <u>sliceWR</u>();
</big></dt>
<dd>Get full read-write slice.<br><br>

</dd>
<dt><big><a name="Owned.sliceWR.2"></a>@trusted WriteBorrowedSlice!(Range, Owned) <u>sliceWR</u>(size_t <i>i</i>, size_t <i>j</i>);
</big></dt>
<dd>Get read-write slice in range <i>i</i> .. <i>j</i>.<br><br>

</dd>
<dt><big><a name="Owned.isBorrowed"></a>const bool <u>isBorrowed</u>();
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff owned container is borrowed.<br><br>

</dd>
<dt><big><a name="Owned.isWriteBorrowed"></a>const bool <u>isWriteBorrowed</u>();
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff owned container is write borrowed.<br><br>

</dd>
<dt><big><a name="Owned.readBorrowCount"></a>const uint <u>readBorrowCount</u>();
</big></dt>
<dd><b>Returns:</b><br>
number of read-only borrowers of owned container.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="move"></a>pure nothrow @nogc @safe void <u>move</u>(Owner)(ref Owner <i>src</i>, ref Owner <i>dst</i>) if (isInstanceOf!(Owned, Owner));
</big></dt>
<dd>Checked overload for <pre style="display:inline;" class="d_inline_code">std.algorithm.mutation.<u>move</u></pre>.
<br><br>
TODO Can we somehow prevent users of Owned from accidentally using
    <pre style="display:inline;" class="d_inline_code">std.algorithm.mutation.<u>move</u></pre> instead of this wrapper?<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
