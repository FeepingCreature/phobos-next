<html><head>
        <!-- Generated by Ddoc from /home/per/Work/justd/arsd/terminal.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>arsd.terminal</title>
        </head><body>
        <h1>arsd.terminal</h1>
Module for interacting with the user's <u>terminal</u>, including color output, cursor manipulation, and full-featured real-time mouse and keyboard input.
<br><br>
The main interface for this module is the Terminal struct, which
	encapsulates the output functions and line-buffered input of the <u>terminal</u>, and
	RealTimeConsoleInput, which gives real time input.
<br><br>

	Creating an instance of these structs will perform console initialization. When the struct
	goes out of scope, any changes in console settings will be automatically reverted.

<br><br>
<b>Note:</b><br>
on Posix, it traps SIGINT and translates it into an input event. You should
	keep your event loop moving and keep an eye open for this to exit cleanly; simply break
	your event loop upon receiving a UserInterruptionEvent. (Without
	the signal handler, ctrl+c can leave your <u>terminal</u> in a bizarre state.)
<br><br>

	As a user, if you have to forcibly kill your program and the event doesn't work, there's still ctrl+\
<br><br>

	On Mac Terminal btw, a lot of hacks are needed and mouse support doesn't work. Most functions basically
	work now though.

<br><br>
<b>ROADMAP:</b><br>

<br><br>

	WHAT I WON'T DO:
	<br><br>

<dl><dt><big><a name="interrupted"></a>bool <u>interrupted</u>;
</big></dt>
<dd>you might periodically check this in a long operation and abort if it is set. Remember it is volatile. It is also sent through the input event loop via RealTimeConsoleInput<br><br>

</dd>
<dt><big><a name="hangedUp"></a>bool <u>hangedUp</u>;
</big></dt>
<dd>similar to interrupted.<br><br>

</dd>
<dt><big><a name="Color"></a>enum <u>Color</u>: ushort;
</big></dt>
<dd>Defines the list of standard colors understood by Terminal.<br><br>

<dl><dt><big><a name="Color.black"></a><u>black</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="Color.red"></a><u>red</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="Color.green"></a><u>green</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="Color.yellow"></a><u>yellow</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="Color.blue"></a><u>blue</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="Color.magenta"></a><u>magenta</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="Color.cyan"></a><u>cyan</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="Color.white"></a><u>white</u></big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ConsoleInputFlags"></a>enum <u>ConsoleInputFlags</u>: int;
</big></dt>
<dd>When capturing input, what events are you interested in?
<br><br>
<b>Note:</b><br>
these flags can be OR'd together to select more than one option at a time.
<br><br>

<br><br>

<br><br>

Ctrl+C and other keyboard input is always captured, though it may be line buffered if you don't use raw.
<br><br>

The rationale for that is to ensure the Terminal destructor has a chance to run, since the terminal is a shared resource and should be put back before the program terminates.<br><br>

<dl><dt><big><a name="ConsoleInputFlags.raw"></a><u>raw</u></big></dt>
<dd><u>raw</u> input returns keystrokes immediately, without line buffering<br><br>

</dd>
<dt><big><a name="ConsoleInputFlags.echo"></a><u>echo</u></big></dt>
<dd>do you want to automatically <u>echo</u> input back to the user?<br><br>

</dd>
<dt><big><a name="ConsoleInputFlags.mouse"></a><u>mouse</u></big></dt>
<dd>capture <u>mouse</u> events<br><br>

</dd>
<dt><big><a name="ConsoleInputFlags.paste"></a><u>paste</u></big></dt>
<dd>capture <u>paste</u> events (note: without this, <u>paste</u> can come through as keystrokes)<br><br>

</dd>
<dt><big><a name="ConsoleInputFlags.size"></a><u>size</u></big></dt>
<dd>window resize events<br><br>

</dd>
<dt><big><a name="ConsoleInputFlags.releasedKeys"></a><u>releasedKeys</u></big></dt>
<dd>key release events. Not reliable on Posix.<br><br>

</dd>
<dt><big><a name="ConsoleInputFlags.allInputEvents"></a><u>allInputEvents</u></big></dt>
<dd>subscribe to all input events. Note: in previous versions, this also returned release events. It no longer does, use allInputEventsWithRelease if you want them.<br><br>

</dd>
<dt><big><a name="ConsoleInputFlags.allInputEventsWithRelease"></a><u>allInputEventsWithRelease</u></big></dt>
<dd>subscribe to all input events, including (unreliable on Posix) key release events.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ConsoleOutputType"></a>enum <u>ConsoleOutputType</u>: int;
</big></dt>
<dd>Defines how terminal output should be handled.<br><br>

<dl><dt><big><a name="ConsoleOutputType.linear"></a><u>linear</u></big></dt>
<dd>do you want output to work one line at a time?<br><br>

</dd>
<dt><big><a name="ConsoleOutputType.cellular"></a><u>cellular</u></big></dt>
<dd>or do you want access to the terminal screen as a grid of characters?<br><br>

</dd>
<dt><big><a name="ConsoleOutputType.minimalProcessing"></a><u>minimalProcessing</u></big></dt>
<dd>do the least possible work, skips most construction and desturction tasks. Only use if you know what you're doing here<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ForceOption"></a>enum <u>ForceOption</u>: int;
</big></dt>
<dd>Some methods will try not to send unnecessary commands to the screen. You can override their judgement using a <u>ForceOption</u> parameter, if present<br><br>

<dl><dt><big><a name="ForceOption.automatic"></a><u>automatic</u></big></dt>
<dd>automatically decide what to do (best, unless you know for sure it isn't right)<br><br>

</dd>
<dt><big><a name="ForceOption.neverSend"></a><u>neverSend</u></big></dt>
<dd>never send the data. This will only update Terminal's internal state. Use with caution.<br><br>

</dd>
<dt><big><a name="ForceOption.alwaysSend"></a><u>alwaysSend</u></big></dt>
<dd>always send the data, even if it doesn't seem necessary<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Terminal"></a>struct <u>Terminal</u>;
</big></dt>
<dd>Encapsulates the I/O capabilities of a terminal.
<br><br>
<b>Warning:</b><br>
do not write out escape sequences to the terminal. This won't work
<br><br>

on Windows and will confuse <u>Terminal</u>'s internal state on Posix.<br><br>

<dl><dt><big><a name="Terminal.this"></a>this(ConsoleOutputType <i>type</i>, int <i>fdIn</i> = 0, int <i>fdOut</i> = 1, int[] delegate() <i>getSizeOverride</i> = null);
</big></dt>
<dd>Constructs an instance of Terminal representing the capabilities of
 the current terminal.
<br><br>
While it is possible to override the stdin+stdout file descriptors, remember
 that is not portable across platforms and be sure you know what you're doing.
<br><br>

 ditto on <i>getSizeOverride</i>. That's there so you can do something instead of ioctl.<br><br>

</dd>
<dt><big><a name="Terminal.setTrueColor"></a>bool <u>setTrueColor</u>(RGB <i>foreground</i>, RGB <i>background</i>, ForceOption <i>force</i> = ForceOption.automatic);
</big></dt>
<dd>Attempts to set color according to a 24 bit value (r, g, b, each &gt;= 0 and &lt; 256).
<br><br>
This is not supported on all terminals. It will attempt to fall back to a 256-color
		or 8-color palette in those cases automatically.

<br><br>
<b>Returns:</b><br>
<b>true</b> if it believes it was successful (note that it cannot be completely sure),
		<b>false</b> if it had to use a fallback.<br><br>

</dd>
<dt><big><a name="Terminal.color"></a>void <u>color</u>(int <i>foreground</i>, int <i>background</i>, ForceOption <i>force</i> = ForceOption.automatic, bool <i>reverseVideo</i> = false);
</big></dt>
<dd>Changes the current <u>color</u>. See enum Color for the values.<br><br>

</dd>
<dt><big><a name="Terminal.underline"></a>void <u>underline</u>(bool <i>set</i>, ForceOption <i>force</i> = ForceOption.automatic);
</big></dt>
<dd><b>Note:</b><br>
the Windows console does not support underlining<br><br>

</dd>
<dt><big><a name="Terminal.reset"></a>void <u>reset</u>();
</big></dt>
<dd>Returns the terminal to normal output colors<br><br>

</dd>
<dt><big><a name="Terminal.cursorX"></a>@property int <u>cursorX</u>();
</big></dt>
<dd>The current x position of the output cursor. 0 == leftmost column<br><br>

</dd>
<dt><big><a name="Terminal.cursorY"></a>@property int <u>cursorY</u>();
</big></dt>
<dd>The current y position of the output cursor. 0 == topmost row<br><br>

</dd>
<dt><big><a name="Terminal.moveTo"></a>void <u>moveTo</u>(int <i>x</i>, int <i>y</i>, ForceOption <i>force</i> = ForceOption.automatic);
</big></dt>
<dd>Moves the output cursor to the given position. (0, 0) is the upper left corner of the screen. The <i>force</i> parameter can be used to <i>force</i> an update, even if Terminal doesn't think it is necessary<br><br>

</dd>
<dt><big><a name="Terminal.showCursor"></a>void <u>showCursor</u>();
</big></dt>
<dd>shows the cursor<br><br>

</dd>
<dt><big><a name="Terminal.hideCursor"></a>void <u>hideCursor</u>();
</big></dt>
<dd>hides the cursor<br><br>

</dd>
<dt><big><a name="Terminal.setTitle"></a>void <u>setTitle</u>(string <i>t</i>);
</big></dt>
<dd>Changes the terminal's title<br><br>

</dd>
<dt><big><a name="Terminal.flush"></a>void <u>flush</u>();
</big></dt>
<dd>Flushes your updates to the terminal.
<br><br>
It is important to call this when you are finished writing for now if you are using the version=with_eventloop<br><br>

</dd>
<dt><big><a name="Terminal.width"></a>@property int <u>width</u>();
</big></dt>
<dd>The current <u>width</u> of the terminal (the number of columns)<br><br>

</dd>
<dt><big><a name="Terminal.height"></a>@property int <u>height</u>();
</big></dt>
<dd>The current <u>height</u> of the terminal (the number of rows)<br><br>

</dd>
<dt><big><a name="Terminal.writef"></a>void <u>writef</u>(T...)(string <i>f</i>, T <i>t</i>);
<br><a name="Terminal.writefln"></a>void <u>writefln</u>(T...)(string <i>f</i>, T <i>t</i>);
<br><a name="Terminal.write"></a>void <u>write</u>(T...)(T <i>t</i>);
<br><a name="Terminal.writeln"></a>void <u>writeln</u>(T...)(T <i>t</i>);
</big></dt>
<dd>Writes to the terminal at the current cursor position.<br><br>

</dd>
<dt><big><a name="Terminal.writeString"></a>deprecated alias <u>writeString</u> = writePrintableString;
</big></dt>
<dd>use write() or writePrintableString instead<br><br>

</dd>
<dt><big><a name="Terminal.clear"></a>void <u>clear</u>();
</big></dt>
<dd>Clears the screen.<br><br>

</dd>
<dt><big><a name="Terminal.getline"></a>string <u>getline</u>(string <i>prompt</i> = null);
</big></dt>
<dd>gets a line, including user editing. Convenience method around the LineGetter class and RealTimeConsoleInput facilities - use them if you need more control.
<br><br>
You really shouldn't call this if stdin isn't actually a user-interactive terminal! So if you expect people to pipe data to your app, check for that or use something else.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RealTimeConsoleInput"></a>struct <u>RealTimeConsoleInput</u>;
</big></dt>
<dd>Encapsulates the stream of input events received from the terminal input.<br><br>

<dl><dt><big><a name="RealTimeConsoleInput.this"></a>this(Terminal* <i>terminal</i>, ConsoleInputFlags <i>flags</i>);
</big></dt>
<dd>To capture input, you need to provide a <i>terminal</i> and some <i>flags</i>.<br><br>

</dd>
<dt><big><a name="RealTimeConsoleInput.kbhit"></a>bool <u>kbhit</u>();
</big></dt>
<dd>Returns <b>true</b> if there iff getch() would not block.
<br><br>
<b>WARNING:</b><br>
<u>kbhit</u> might consume input that would be ignored by getch. This
		function is really only meant to be used in conjunction with getch. Typically,
		you should use a full-fledged event loop if you want all kinds of input. <u>kbhit</u>+getch
		are just for simple keyboard driven applications.<br><br>

</dd>
<dt><big><a name="RealTimeConsoleInput.timedCheckForInput"></a>bool <u>timedCheckForInput</u>(int <i>milliseconds</i>);
</big></dt>
<dd>Check for input, waiting no longer than the number of <i>milliseconds</i><br><br>

</dd>
<dt><big><a name="RealTimeConsoleInput.getch"></a>dchar <u>getch</u>(bool <i>nonblocking</i> = false);
</big></dt>
<dd>Get one key press from the terminal, discarding other
<br><br>
events in the process. Returns dchar.init upon receiving end-of-file.
<br><br>

<br><br>

<br><br>

Be aware that this may return non-character key events, like F1, F2, arrow keys, etc., as private use Unicode characters. Check them against KeyboardEvent.Key if you like.<br><br>

</dd>
<dt><big><a name="RealTimeConsoleInput.nextEvent"></a>InputEvent <u>nextEvent</u>();
</big></dt>
<dd>Returns the next event.
<br><br>
<b>Experimental:</b><br>
It is also possible to integrate this into
<br><br>

a generic event loop, currently under -version=with_eventloop and it will
<br><br>

require the module arsd.eventloop (Linux only at this point)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="KeyboardEvent"></a>struct <u>KeyboardEvent</u>;
</big></dt>
<dd>The new style of keyboard event<br><br>

<dl><dt><big><a name="KeyboardEvent.Key"></a>enum <u>Key</u>: dchar;
</big></dt>
<dd>.<br><br>

<dl><dt><big><a name="KeyboardEvent.Key.escape"></a><u>escape</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F1"></a><u>F1</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F2"></a><u>F2</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F3"></a><u>F3</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F4"></a><u>F4</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F5"></a><u>F5</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F6"></a><u>F6</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F7"></a><u>F7</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F8"></a><u>F8</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F9"></a><u>F9</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F10"></a><u>F10</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F11"></a><u>F11</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.F12"></a><u>F12</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.LeftArrow"></a><u>LeftArrow</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.RightArrow"></a><u>RightArrow</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.UpArrow"></a><u>UpArrow</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.DownArrow"></a><u>DownArrow</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.Insert"></a><u>Insert</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.Delete"></a><u>Delete</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.Home"></a><u>Home</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.End"></a><u>End</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.PageUp"></a><u>PageUp</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="KeyboardEvent.Key.PageDown"></a><u>PageDown</u></big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
</dl>
</dd>
<dt><big><a name="CharacterEvent"></a>struct <u>CharacterEvent</u>;
</big></dt>
<dd>Input event for characters<br><br>

<dl><dt><big><a name="CharacterEvent.Type"></a>enum <u>Type</u>: int;
</big></dt>
<dd>.<br><br>

<dl><dt><big><a name="CharacterEvent.Type.Released"></a><u>Released</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="CharacterEvent.Type.Pressed"></a><u>Pressed</u></big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="CharacterEvent.eventType"></a>Type <u>eventType</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="CharacterEvent.character"></a>dchar <u>character</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="CharacterEvent.modifierState"></a>uint <u>modifierState</u>;
</big></dt>
<dd>Don't depend on this to be available for character events<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PasteEvent"></a>struct <u>PasteEvent</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big><a name="PasteEvent.pastedText"></a>string <u>pastedText</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="MouseEvent"></a>struct <u>MouseEvent</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big><a name="MouseEvent.Type"></a>enum <u>Type</u>: int;
</big></dt>
<dd>.<br><br>

<dl><dt><big><a name="MouseEvent.Type.Moved"></a><u>Moved</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Type.Pressed"></a><u>Pressed</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Type.Released"></a><u>Released</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Type.Clicked"></a><u>Clicked</u></big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="MouseEvent.eventType"></a>Type <u>eventType</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Button"></a>enum <u>Button</u>: uint;
</big></dt>
<dd>.<br><br>

<dl><dt><big><a name="MouseEvent.Button.None"></a><u>None</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Button.Left"></a><u>Left</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Button.Middle"></a><u>Middle</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Button.Right"></a><u>Right</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Button.ScrollUp"></a><u>ScrollUp</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="MouseEvent.Button.ScrollDown"></a><u>ScrollDown</u></big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="MouseEvent.buttons"></a>uint <u>buttons</u>;
</big></dt>
<dd>A mask of Button<br><br>

</dd>
<dt><big><a name="MouseEvent.x"></a>int <u>x</u>;
</big></dt>
<dd>0 == left side<br><br>

</dd>
<dt><big><a name="MouseEvent.y"></a>int <u>y</u>;
</big></dt>
<dd>0 == top<br><br>

</dd>
<dt><big><a name="MouseEvent.modifierState"></a>uint <u>modifierState</u>;
</big></dt>
<dd>shift, ctrl, alt, meta, altgr. Not always available. Always check by using <u>modifierState</u> &amp; ModifierState.something<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="SizeChangedEvent"></a>struct <u>SizeChangedEvent</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="UserInterruptionEvent"></a>struct <u>UserInterruptionEvent</u>;
</big></dt>
<dd>the user hitting ctrl+c will send this
<br><br>
You should drop what you're doing and perhaps exit when this happens.<br><br>

</dd>
<dt><big><a name="HangupEvent"></a>struct <u>HangupEvent</u>;
</big></dt>
<dd>If the user hangs up (for example, closes the terminal emulator without exiting the app), this is sent.
<br><br>
If you receive it, you should generally cleanly exit.<br><br>

</dd>
<dt><big><a name="EndOfFileEvent"></a>struct <u>EndOfFileEvent</u>;
</big></dt>
<dd>Sent upon receiving end-of-file from stdin.<br><br>

</dd>
<dt><big><a name="InputEvent"></a>struct <u>InputEvent</u>;
</big></dt>
<dd>GetNextEvent returns this. Check the type, then use get to get the more detailed input<br><br>

<dl><dt><big><a name="InputEvent.Type"></a>enum <u>Type</u>: int;
</big></dt>
<dd>.<br><br>

<dl><dt><big><a name="InputEvent.Type.KeyboardEvent"></a><u>KeyboardEvent</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="InputEvent.Type.CharacterEvent"></a><u>CharacterEvent</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="InputEvent.Type.NonCharacterKeyEvent"></a><u>NonCharacterKeyEvent</u></big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="InputEvent.Type.PasteEvent"></a><u>PasteEvent</u></big></dt>
<dd>The user pasted some text. Not always available, the pasted text might come as a series of character events instead.<br><br>

</dd>
<dt><big><a name="InputEvent.Type.MouseEvent"></a><u>MouseEvent</u></big></dt>
<dd>only sent if you subscribed to mouse events<br><br>

</dd>
<dt><big><a name="InputEvent.Type.SizeChangedEvent"></a><u>SizeChangedEvent</u></big></dt>
<dd>only sent if you subscribed to size events<br><br>

</dd>
<dt><big><a name="InputEvent.Type.UserInterruptionEvent"></a><u>UserInterruptionEvent</u></big></dt>
<dd>the user hit ctrl+c<br><br>

</dd>
<dt><big><a name="InputEvent.Type.EndOfFileEvent"></a><u>EndOfFileEvent</u></big></dt>
<dd>stdin has received an end of file<br><br>

</dd>
<dt><big><a name="InputEvent.Type.HangupEvent"></a><u>HangupEvent</u></big></dt>
<dd>the terminal hanged up - for example, if the user closed a terminal emulator<br><br>

</dd>
<dt><big><a name="InputEvent.Type.CustomEvent"></a><u>CustomEvent</u></big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="InputEvent.type"></a>@property Type <u>type</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="InputEvent.terminal"></a>@property Terminal* <u>terminal</u>();
</big></dt>
<dd>Returns a pointer to the <u>terminal</u> associated with this event.
<br><br>
(You can usually just ignore this as there's only one <u>terminal</u> typically.)
<br><br>

<br><br>

<br><br>

It may be <b>null</b> in the case of program-generated events;<br><br>

</dd>
<dt><big><a name="InputEvent.get"></a>@property auto <u>get</u>(Type T)();
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="LineGetter"></a>class <u>LineGetter</u>;
</big></dt>
<dd><b>FIXME:</b><br>
support lines that wrap
<br><br>
<b>FIXME:</b><br>
better controls maybe

<br><br>
<b>FIXME:</b><br>
support multi-line "lines" and some form of line continuation, both
	       from the user (if permitted) and from the application, so like the user
	       hits "class foo { \n" and the app says "that line needs continuation" automatically.

<br><br>
<b>FIXME:</b><br>
fix lengths on prompt and suggestion
<br><br>

	A note on history:
<br><br>

	To save history, you must call <u>LineGetter</u>.dispose() when you're done with it.
	History will not be automatically saved without that call!
<br><br>

	The history saving and loading as a trivially encountered race condition: if you
	open two programs that use the same one at the same time, the one that closes second
	will overwrite any history changes the first closer saved.
<br><br>

	GNU Getline does this too... and it actually kinda drives me nuts. But I don't know
	what a good fix is except for doing a transactional commit straight to the file every
	time and that seems like hitting the disk way too often.
<br><br>

	We could also do like a history server like a database daemon that keeps the order
	correct but I don't actually like that either because I kinda like different bashes
	to have different history, I just don't like it all to get lost.
<br><br>

	Regardless though, this isn't even used in bash anyway, so I don't think I care enough
	to put that much effort into it. Just using separate files for separate tasks is good
	enough I think.<br><br>

<dl><dt><big><a name="LineGetter.this"></a>this(Terminal* <i>tty</i>, string <i>historyFilename</i> = null);
</big></dt>
<dd>Make sure that the parent terminal struct remains in scope for the duration
<br><br>
of LineGetter's lifetime, as it does hold on to and use the passed pointer
<br><br>

throughout.
<br><br>

<br><br>

<br><br>

<i>historyFilename</i> will load and save an input history log to a particular folder.
<br><br>

Leaving it <b>null</b> will mean no file will be used and history will not be saved across sessions.<br><br>

</dd>
<dt><big><a name="LineGetter.dispose"></a>void <u>dispose</u>();
</big></dt>
<dd>Call this before letting LineGetter die so it can do any necessary
<br><br>
cleanup and save the updated history to a file.<br><br>

</dd>
<dt><big><a name="LineGetter.historyFileDirectory"></a>string <u>historyFileDirectory</u>();
</big></dt>
<dd>Override this to change the directory where history files are stored
<br><br>
Default is $HOME/.arsd-getline on linux and %APPDATA%/arsd-getline/ on Windows.<br><br>

</dd>
<dt><big><a name="LineGetter.suggestionForeground"></a>Color <u>suggestionForeground</u>;
</big></dt>
<dd>You can customize the colors here. You should set these after construction, but before
<br><br>
calling startGettingLine or getline.<br><br>

</dd>
<dt><big><a name="LineGetter.regularForeground"></a>Color <u>regularForeground</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="LineGetter.background"></a>Color <u>background</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="LineGetter.prompt"></a>string <u>prompt</u>;
</big></dt>
<dd>Set this if you want a <u>prompt</u> to be drawn with the line. It does NOT support color in string.<br><br>

</dd>
<dt><big><a name="LineGetter.autoSuggest"></a>bool <u>autoSuggest</u>;
</big></dt>
<dd>Turn on auto suggest if you want a greyed thing of what tab
<br><br>
would be able to fill in as you type.
<br><br>

<br><br>

<br><br>

You might want to turn it off if generating a completion list is slow.<br><br>

</dd>
<dt><big><a name="LineGetter.historyFilter"></a>string <u>historyFilter</u>(string <i>candidate</i>);
</big></dt>
<dd>Override this if you don't want all lines added to the history.
<br><br>
You can return <b>null</b> to not add it at all, or you can transform it.<br><br>

</dd>
<dt><big><a name="LineGetter.saveSettingsAndHistoryToFile"></a>void <u>saveSettingsAndHistoryToFile</u>();
</big></dt>
<dd>You may override this to do nothing<br><br>

</dd>
<dt><big><a name="LineGetter.loadSettingsAndHistoryFromFile"></a>void <u>loadSettingsAndHistoryFromFile</u>();
</big></dt>
<dd>You may override this to do nothing<br><br>

</dd>
<dt><big><a name="LineGetter.tabComplete"></a>protected string[] <u>tabComplete</u>(in dchar[] <i>candidate</i>);
</big></dt>
<dd>Override this to provide tab completion. You may use the <i>candidate</i>
		argument to filter the list, but you don't have to (LineGetter will
		do it for you on the values you return).
<br><br>
Ideally, you wouldn't return more than about ten items since the list
		gets difficult to use if it is too long.
<br><br>

		Default is to provide recent command history as autocomplete.<br><br>

</dd>
<dt><big><a name="LineGetter.showTabCompleteList"></a>protected void <u>showTabCompleteList</u>(string[] <i>list</i>);
</big></dt>
<dd>Override this to provide a custom display of the tab completion <i>list</i><br><br>

</dd>
<dt><big><a name="LineGetter.getline"></a>string <u>getline</u>(RealTimeConsoleInput* <i>input</i> = null);
</big></dt>
<dd>One-call shop for the main workhorse
<br><br>
If you already have a RealTimeConsoleInput ready to go, you
<br><br>

should pass a pointer to yours here. Otherwise, LineGetter will
<br><br>

make its own.<br><br>

</dd>
<dt><big><a name="LineGetter.addChar"></a>void <u>addChar</u>(dchar <i>ch</i>);
</big></dt>
<dd>Adds a character at the current position in the line. You can call this too if you hook events for hotkeys or something.
<br><br>
You'll probably want to call redraw() after adding chars.<br><br>

</dd>
<dt><big><a name="LineGetter.addString"></a>void <u>addString</u>(string <i>s</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big><a name="LineGetter.deleteChar"></a>void <u>deleteChar</u>();
</big></dt>
<dd>Deletes the character at the current position in the line.
<br><br>
You'll probably want to call redraw() after deleting chars.<br><br>

</dd>
<dt><big><a name="LineGetter.deleteToEndOfLine"></a>void <u>deleteToEndOfLine</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="LineGetter.startGettingLine"></a>void <u>startGettingLine</u>();
</big></dt>
<dd>Starts getting a new line. Call workOnLine and finishGettingLine afterward.
<br><br>
Make sure that you've flushed your input and output before calling this
<br><br>

function or else you might lose events or get exceptions from this.<br><br>

</dd>
<dt><big><a name="LineGetter.workOnLine"></a>bool <u>workOnLine</u>(InputEvent <i>e</i>);
</big></dt>
<dd>for integrating into another event loop
<br><br>
you can pass individual events to this and
<br><br>

the line getter will work on it
<br><br>

<br><br>

<br><br>

returns <b>false</b> when there's nothing more to do<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="LineGetterConstructors"></a>template <u>LineGetterConstructors</u>()</big></dt>
<dd>Adds default constructors that just forward to the superclass<br><br>

</dd>
<dt><big><a name="FileLineGetter"></a>class <u>FileLineGetter</u>: <u>arsd.terminal.LineGetter</u>;
</big></dt>
<dd>This is a line getter that customizes the tab completion to
<br><br>
fill in file names separated by spaces, like a command line thing.<br><br>

<dl><dt><big><a name="FileLineGetter.searchDirectory"></a>string <u>searchDirectory</u>;
</big></dt>
<dd>You can set this property to tell it where to search for the files
<br><br>
to complete.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RGB"></a>struct <u>RGB</u>;
</big></dt>
<dd>Represents a 24-bit color.
<br><br>
	
<br><br>

<dl><dt><big><a name="RGB.r"></a>ubyte <u>r</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGB.g"></a>ubyte <u>g</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RGB.b"></a>ubyte <u>b</u>;
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
