<html><head>
        <!-- Generated by Ddoc from /home/per/Work/phobos-next/src/bound.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>bound</title>
        </head><body>
        <h1>bound</h1>
Bounded Arithmetic Wrapper Type, similar to Ada Range/Interval Types.
<br><br>
<b>License:</b><br>
.
<br><br>
<b>Authors:</b><br>
 
<br><br>

    See also: http://en.wikipedia.org/wiki/Interval_arithmetic
    See also: https://bitbucket.org/davidstone/bounded_integer
    See also: http://stackoverflow.com/questions/18514806/ada-like-types-in-nimrod
    See also: http://forum.dlang.org/thread/xogeuqdwdjghkklzkfhl@forum.dlang.org#post-rksboytciisyezkapxkr:40forum.dlang.org
    See also: http://forum.dlang.org/thread/lxdtukwzlbmzebazusgb@forum.dlang.org#post-ymqdbvrwoupwjycpizdi:40forum.dlang.org
    See also: http://dlang.org/operatoroverloading.html
<br><br>

    TODO Test with geometry.Vector or geometry.Point
<br><br>

    TODO Make stuff @safe pure @nogc and in some case nothrow
<br><br>

    TODO Implement overload for conditional operator p ? x1 : x2
    TODO Propagate ranges in arithmetic (opUnary, opBinary, opOpAssign):
          - Integer: +,-,*,^^,/
          - FloatingPoint: +,-,*,/,^^,sqrt,
<br><br>

    TODO Should implicit conversions to un-Bounds be allowed?
    Not in https://bitbucket.org/davidstone/bounded_integer.
<br><br>

    TODO Merge with limited
    TODO Is this a good idea to use?:
    import std.meta;
    mixin Proxy!t;             // Limited acts as V (almost).
    invariant() {
    enforce(t &gt;= low &amp;&amp; t &lt;= high);
    wln("fdsf");
<br><br>

    TODO If these things take to long to evaluted at compile-time maybe we need
    to build it into the language for example using a new syntax either using
    - integer(range:low..high, step:1)
    - int(range:low..high, step:1)
    - num(range:low..high, step:1)
<br><br>

    TODO Use
    V saveOp(string op, V)(V x, V y) pure @save @nogc if(isIntegral!V
    &amp;&amp; (op=="+" || op=="-" || op=="&lt;&lt;" || op=="*"))
    {
    mixin("x "~op~"= y");
    static if(isSigned!V)
    {
    static if(op == "*")
    {
    asm naked { jnc opok; }
    }
    else
    {
    asm naked { jno opok; }
    }
    x = V.min;
    }
    else // unsigned
    {
    asm naked { jnc opok; }
    x = V.max;
    }
<br><br>
<b>opok:</b><br>
return x;
    }
<br><br>

    TODO Reuse core.checkedint
<br><br>

    TODO Move to Phobos std.typecons<br><br>

<dl><dt><big><a name="Policy"></a>enum <u>Policy</u>: int;
</big></dt>
<dd>TODO Use Boundness <u>Policy</u>.<br><br>

</dd>
<dt><big><a name="BoundOverflowException"></a>class <u>BoundOverflowException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when  values overflows or underflows.<br><br>

</dd>
<dt><big><a name="isCTEable"></a>enum auto <u>isCTEable</u>(alias expr);
</big></dt>
<dd>Check if the value of  is known at compile-time.
    See also: http://forum.dlang.org/thread/owlwzvidwwpsrelpkbok@forum.dlang.org<br><br>

</dd>
<dt><big><a name="isBoundable"></a>enum auto <u>isBoundable</u>(T);
</big></dt>
<dd>Check if Type  can wrapped in a .<br><br>

</dd>
<dt><big><a name="areBoundable"></a>enum auto <u>areBoundable</u>(T, U);
</big></dt>
<dd>Check if Types  and  can wrapped in a .<br><br>

</dd>
<dt><big><a name="isCTBound"></a>enum auto <u>isCTBound</u>(alias expr);
</big></dt>
<dd>Check if Expression  is a CT-expression that can be used as a Bound.<br><br>

</dd>
<dt><big><a name="areCTBoundable"></a>enum auto <u>areCTBoundable</u>(alias low, alias high);
</big></dt>
<dd>TODO Use this.<br><br>

</dd>
<dt><big><a name="BoundsType"></a>template <u>BoundsType</u>(alias low, alias high, bool packed = true, bool signed = false) if (isCTBound!low &amp;&amp; isCTBound!high)</big></dt>
<dd>Get Type that can contain the inclusive bound [low, high].
    If  optimize storage for compactness otherwise for speed.
    If  use a signed integer.<br><br>

</dd>
<dt><big><a name="Bound"></a>struct <u>Bound</u>(V, alias low, alias high, bool optional = false, bool exceptional = true, bool packed = true, bool signed = false);
</big></dt>
<dd>Value of Type  bound inside Inclusive Range [low, high].
<br><br>
If  is <b>true</b> this stores one extra undefined state (similar to Haskell's Maybe).
<br><br>

    If  is <b>true</b> range errors will throw a
    , otherwise truncation plus warnings will issued.<br><br>

<dl><dt><big><a name="Bound.min"></a>static pure nothrow @property @safe auto <u>min</u>();
</big></dt>
<dd>Get Low Inclusive Bound.<br><br>

</dd>
<dt><big><a name="Bound.max"></a>static pure nothrow @property @safe auto <u>max</u>();
</big></dt>
<dd>Get High Inclusive Bound.<br><br>

</dd>
<dt><big><a name="Bound.this"></a>this(U, string file = __FILE__, int line = __LINE__)(U <i>rhs</i>) if (areBoundable!(V, U));
</big></dt>
<dd>Construct from unbounded value .<br><br>

</dd>
<dt><big><a name="Bound.opAssign"></a>auto <u>opAssign</u>(U, string file = __FILE__, int line = __LINE__)(U <i>rhs</i>) if (areBoundable!(V, U));
</big></dt>
<dd>Assigne from unbounded value .<br><br>

</dd>
<dt><big><a name="Bound.this.2"></a>this(U, alias low_, alias high_)(Bound!(U, low_, high_, optional, exceptional, packed, signed) <i>rhs</i>) if (low &lt;= low_ &amp;&amp; high_ &lt;= high);
</big></dt>
<dd>Construct from  value .<br><br>

</dd>
<dt><big><a name="Bound.opAssign.2"></a>auto <u>opAssign</u>(U, alias low_, alias high_)(Bound!(U, low_, high_, optional, exceptional, packed, signed) <i>rhs</i>) if (low &lt;= low_ &amp;&amp; high_ &lt;= high &amp;&amp; haveCommonType!(V, U));
</big></dt>
<dd>Assign from  value .<br><br>

</dd>
<dt><big><a name="Bound.defined"></a>const pure nothrow @property @safe bool <u>defined</u>();
</big></dt>
<dd>Check if this value is <u>defined</u>.<br><br>

</dd>
<dt><big><a name="Bound.check"></a>static pure @trusted string <u>check</u>();
</big></dt>
<dd>Check that last operation was a success.<br><br>

</dd>
<dt><big><a name="Bound.checkAssign"></a>void <u>checkAssign</u>(U, string file = __FILE__, int line = __LINE__)(U <i>rhs</i>);
</big></dt>
<dd>Check that assignment from  is ok.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="bound"></a>template <u>bound</u>(alias value) if (isCTBound!value)</big></dt>
<dd>Instantiate \c Bound from a single expression .
    Makes it easier to add free-contants to existing Bounded variables.<br><br>

</dd>
<dt><big><a name="bound.2"></a>auto <u>bound</u>(alias low, alias high, bool optional = false, bool exceptional = true, bool packed = true, bool signed = false)() if (isCTBound!low &amp;&amp; isCTBound!high);
</big></dt>
<dd>Instantiator for \c Bound.
    Bounds  and  infer type of internal value.
    If  optimize storage for compactness otherwise for speed.
 \see http://stackoverflow.com/questions/17502664/instantiator-function-for-bound-template-doesnt-compile<br><br>

</dd>
<dt><big><a name="saturated"></a>ref auto <u>saturated</u>(V, bool optional = false, bool packed = true)(V <i>x</i>);
</big></dt>
<dd>Return  with Automatic Packed Saturation.
    If  optimize storage for compactness otherwise for speed.<br><br>

</dd>
<dt><big><a name="optional"></a>ref auto <u>optional</u>(V, bool packed = true)(V <i>x</i>);
</big></dt>
<dd>Return  with Automatic Packed Saturation.
    If  optimize storage for compactness otherwise for speed.<br><br>

</dd>
<dt><big><a name="min"></a>auto <u>min</u>(V1, alias low1, alias high1, V2, alias low2, alias high2, bool optional = false, bool exceptional = true, bool packed = true, bool signed = false)(Bound!(V1, low1, high1, optional, exceptional, packed, signed) <i>a1</i>, Bound!(V2, low2, high2, optional, exceptional, packed, signed) <i>a2</i>);
</big></dt>
<dd>Calculate Minimum.
    TODO variadic.<br><br>

</dd>
<dt><big><a name="max"></a>auto <u>max</u>(V1, alias low1, alias high1, V2, alias low2, alias high2, bool optional = false, bool exceptional = true, bool packed = true, bool signed = false)(Bound!(V1, low1, high1, optional, exceptional, packed, signed) <i>a1</i>, Bound!(V2, low2, high2, optional, exceptional, packed, signed) <i>a2</i>);
</big></dt>
<dd>Calculate Maximum.
    TODO variadic.<br><br>

</dd>
<dt><big><a name="abs"></a>auto <u>abs</u>(V, alias low, alias high, bool optional = false, bool exceptional = true, bool packed = true, bool signed = false)(Bound!(V, low, high, optional, exceptional, packed, signed) <i>a</i>);
</big></dt>
<dd>Calculate Absolute Value of .<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Per Nordl√∂w 2014-.
</small>
        </body></html>
