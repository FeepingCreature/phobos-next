<html><head>
        <!-- Generated by Ddoc from trie.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>trie</title>
        </head><body>
        <h1>trie</h1>
Tries and Prefix Trees.
<br><br>
Implementation is layered:
    <ul>    <li><pre style="display:inline;" class="d_inline_code">RawRadixTree</pre> stores its untyped keys as variable length ubyte-strings (<pre style="display:inline;" class="d_inline_code">UKey</pre>)</li>
    <li>On top of that <pre style="display:inline;" class="d_inline_code">RadixTree</pre> implements typed-key access via its template parameter <pre style="display:inline;" class="d_inline_code">Key</pre>.</li>
    </ul>
    Both layers currently
    <ul>    <li>have template parameterization on the <pre style="display:inline;" class="d_inline_code">Value</pre>-type in the map case (when <pre style="display:inline;" class="d_inline_code">Value</pre> is non-<pre style="display:inline;" class="d_inline_code">void</pre>)</li>
    <li>are completely <pre style="display:inline;" class="d_inline_code">@nogc</pre> and, when possible, <pre style="display:inline;" class="d_inline_code">@safe pure nothrow</pre></li>
    <li>Insertion with returned modifications status: <pre style="display:inline;" class="d_inline_code">auto newKeyWasInserted = set.insert(Key key)</pre></li>
    <li>Support AA-style <pre style="display:inline;" class="d_inline_code">in</pre>-operator</li>
      <ul>      <li><pre style="display:inline;" class="d_inline_code">key in set</pre> is <pre style="display:inline;" class="d_inline_code">bool</pre> for set-case</li>
      <li><pre style="display:inline;" class="d_inline_code">key in map</pre> returns non-<pre style="display:inline;" class="d_inline_code">null</pre> <pre style="display:inline;" class="d_inline_code">value</pre> pointer when <pre style="display:inline;" class="d_inline_code">key</pre> is stored in <pre style="display:inline;" class="d_inline_code">map</pre></li>
      </ul>
    <li>AA-style iteration of map keys: <pre style="display:inline;" class="d_inline_code">map.byKey()</pre></li>
    <li>AA-style iteration of map values: <pre style="display:inline;" class="d_inline_code">map.byValue()</pre></li>
    <li><pre style="display:inline;" class="d_inline_code">SortedRange</pre>-style iteration over elements sorted by key: <pre style="display:inline;" class="d_inline_code">assert(set[].isSorted)</pre></li>
    <li>Containment checking: <pre style="display:inline;" class="d_inline_code">bool contains(in Key key)</pre></li>
    <li>Element indexing and element index assignment for map case via <pre style="display:inline;" class="d_inline_code">opIndex</pre> and <pre style="display:inline;" class="d_inline_code">opIndexAssign</pre></li>
    <li>Key-Prefix Completion (returning a <pre style="display:inline;" class="d_inline_code">Range</pre> over all set/map-elements that match a key prefix): <pre style="display:inline;" class="d_inline_code">prefix(Key keyPrefix)</pre></li>
    </ul>
    Typed layer supports
    <ul>    <li>ordered access of aggregate types</li>
    </ul>

<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>
 for a descriptive usage of prefixed access.
<br><br>

    TODO Use scope on <pre style="display:inline;" class="d_inline_code">Range</pre>, <pre style="display:inline;" class="d_inline_code">RawRange</pre> and members that return key and value reference when DIP-1000 has been implemented
<br><br>

    TODO Encode and <pre style="display:inline;" class="d_inline_code">string</pre> with zero-terminating 0 byte
<br><br>

    TODO
<br><br>

    Replace
    case undefined: return typeof(return).init; // terminate recursion
    with
    case undefined: return curr;

<br><br>
<b>TODO:</b><br>
    TODO Make <pre style="display:inline;" class="d_inline_code">Key</pre> and Ix[]-array of <pre style="display:inline;" class="d_inline_code">immutable Ix</pre> like <pre style="display:inline;" class="d_inline_code">string</pre>
<br><br>

    TODO Allow <pre style="display:inline;" class="d_inline_code">Node</pre>-constructors to take const and immutable prefixes and then
    make <pre style="display:inline;" class="d_inline_code">toRawKey</pre> and <pre style="display:inline;" class="d_inline_code">toTypedKey</pre> accept return const-slices
<br><br>

    TODO Use <pre style="display:inline;" class="d_inline_code">expandVariableLength</pre> in <pre style="display:inline;" class="d_inline_code">reconstructingInsert</pre> that uses
    x.realloc(2*n) instead of x.free(n)-malloc(2*n)
<br><br>

    TODO Remove @trusted from VLA (variable length array)-members of SparseBranch/SparseLeaf and make their callers @trusted instead.
    TODO Assure that ~this() is run for argument <pre style="display:inline;" class="d_inline_code">nt</pre> in <pre style="display:inline;" class="d_inline_code">freeNode</pre>. Can we use <pre style="display:inline;" class="d_inline_code">postblit()</pre> for this?
    TODO Search for "functionize this loop or reuse memmove" and use move()
    TODO Add Branch-hint allocation flag and re-benchmark construction of <pre style="display:inline;" class="d_inline_code">radixTreeSet</pre> with 10000000 uints
    TODO Add sortedness to <pre style="display:inline;" class="d_inline_code">IxsN</pre> and make <pre style="display:inline;" class="d_inline_code">IxsN.contains()</pre> use <pre style="display:inline;" class="d_inline_code">binarySearch()</pre>. Make use of <pre style="display:inline;" class="d_inline_code">sortn</pre>.
    TODO Check for case when expanding to bit-branch instead of <pre style="display:inline;" class="d_inline_code">SparseBranch</pre> in all <pre style="display:inline;" class="d_inline_code">expand()</pre> overloads
    TODO Make array indexing/slicing as @trusted and use .ptr[] instead of [] when things are stable.
    TODO Add various extra packings in MixLeaf1to4: number of
    - Ix  (0,1,2,3,4,5,6): 3-bits
    - Ix2 (0,1,2,3): 2-bits
    - Ix3 (0,1,2): 2-bits
    - Ix4 (0,1): 1-bit
    Total bits 8-bits
    Possible packings with 6 bytes
    - 4_
    - 4_2
    - 4_2
    - 4_2_1
    - 4_1
    - 4_1_1
    - 3_2
    - 3_2_1
    - 3_1
    - 3_1_1
    - 3_1_1_1
    - 2_2_2
    - 2_2
    - 2_2_1
    - 2_2_1_1
    - 2
    - 2_1
    - 2_1_1
    - 2_1_1_1
    - 2_1_1_1_1
    - 1
    - 1_1
    - 1_1_1
    - 1_1_1_1
    - 1_1_1_1_1
    - 1_1_1_1_1_1
<br><br>

    TODO Sorted Range Primitives over Keys
<br><br>

    - Returns a range of elements which are equivalent (though not necessarily equal) to value.
      auto equalRange(this This)(inout T value)
<br><br>

    - Returns a range of elements which are greater than low and smaller than highValue.
      auto bound(this This)(inout T lowValue, inout T highValue)
<br><br>

    - Returns a range of elements which are less than value.
      auto lowerBound(this This)(inout T value)
<br><br>

    - Returns a range of elements which are greater than value.
      auto upperBound(this This)(inout T value)
<br><br>

    TODO opBinaryRight shall return <pre style="display:inline;" class="d_inline_code">_rawTree.ElementRef</pre> instead of <pre style="display:inline;" class="d_inline_code">bool</pre>
<br><br>

    TODO Fix vla-allocations in constructVariableLength according
    C11-recommendations. For reference set commit
    d2f1971dd570439da4198fa76603b53b072060f8 at
<br><br>
<b>https:</b><br>
//github.com/emacs-mirror/emacs.git<br><br>

<dl><dt><big><a name="isScalarTrieableKeyType"></a>enum auto <u>isScalarTrieableKeyType</u>(T);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code">T</pre> is a scalar trie key-type, <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.<br><br>

</dd>
<dt><big><a name="isTrieableKeyType"></a>template <u>isTrieableKeyType</u>(T)</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code">T</pre> is a type that can be stored as a key in a trie, <pre style="display:inline;" class="d_inline_code"> false</pre> otherwise.<br><br>

</dd>
<dt><big><a name="Ix"></a>alias <u>Ix</u> = modulo.Mod!(256LU, ubyte).Mod;
</big></dt>
<dd>Radix Modulo Index
    Restricted index type avoids range checking in array indexing below.<br><br>

</dd>
<dt><big><a name="Key"></a>template <u>Key</u>(size_t span)</big></dt>
<dd>Mutable RawTree <u>Key</u>.<br><br>

</dd>
<dt><big><a name="IKey"></a>template <u>IKey</u>(size_t span)</big></dt>
<dd>Immutable RawTree Key.<br><br>

</dd>
<dt><big><a name="KeyN"></a>template <u>KeyN</u>(size_t span, size_t N)</big></dt>
<dd>Fixed-Length RawTree Key.<br><br>

</dd>
<dt><big><a name="ModStatus"></a>enum <u>ModStatus</u>: ubyte;
</big></dt>
<dd>Results of attempt at modification sub.<br><br>

</dd>
<dt><big><a name="cacheLineSize"></a>enum int <u>cacheLineSize</u>;
</big></dt>
<dd>Size of a CPU cache line in bytes.
<br><br>
Container layouts should be adapted to make use of at least this many bytes
    in its nodes.<br><br>

</dd>
<dt><big><a name="OneLeafMax7"></a>struct <u>OneLeafMax7</u>;
</big></dt>
<dd>Single/1-Key Leaf with maximum key-length 7.<br><br>

</dd>
<dt><big><a name="TwoLeaf3"></a>struct <u>TwoLeaf3</u>;
</big></dt>
<dd>Binary/2-Key Leaf with key-length 3.<br><br>

</dd>
<dt><big><a name="TriLeaf2"></a>struct <u>TriLeaf2</u>;
</big></dt>
<dd>Ternary/3-Key Leaf with key-length 2.<br><br>

</dd>
<dt><big><a name="HeptLeaf1"></a>struct <u>HeptLeaf1</u>;
</big></dt>
<dd>Hepa/7-Key Leaf with key-length 1.<br><br>

</dd>
<dt><big><a name="construct"></a>pure nothrow @nogc @trusted auto <u>construct</u>(NodeType, Args...)(Args <i>args</i>) if (!hasVariableLength!NodeType);
</big></dt>
<dd>Allocate (if pointer) and Construct a <pre style="display:inline;" class="d_inline_code">Node</pre>-type of value type <pre style="display:inline;" class="d_inline_code">NodeType</pre>
    using constructor arguments <pre style="display:inline;" class="d_inline_code"><i>args</i></pre> of <pre style="display:inline;" class="d_inline_code">Args</pre>.<br><br>

</dd>
<dt><big><a name="FixedKeyLeafN"></a>alias <u>FixedKeyLeafN</u> = variant_ex.WordVariant!(OneLeafMax7, TwoLeaf3, TriLeaf2).WordVariant;
</big></dt>
<dd>Fixed-Length leaf Key-only Node.<br><br>

</dd>
<dt><big><a name="Leaf1"></a>template <u>Leaf1</u>(Value)</big></dt>
<dd>Mutable leaf node of 1-Ix leaves.
    Used by branch-leaf.<br><br>

</dd>
<dt><big><a name="firstIx"></a>UIx <u>firstIx</u>(Value)(Leaf1!Value <i>curr</i>);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code">key</pre> is stored under <pre style="display:inline;" class="d_inline_code"><i>curr</i></pre>, <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.<br><br>

</dd>
<dt><big><a name="tryNextIx"></a>bool <u>tryNextIx</u>(Value)(Leaf1!Value <i>curr</i>, const UIx <i>ix</i>, out Ix <i>nextIx</i>);
</big></dt>
<dd>Try to iterate leaf index <pre style="display:inline;" class="d_inline_code"><i>ix</i></pre> to index, either sparse or dense and put result in <pre style="display:inline;" class="d_inline_code"><i>nextIx</i></pre>.
<br><br>
<b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code"><i>nextIx</i></pre> was set, <pre style="display:inline;" class="d_inline_code">false</pre> if no more indexes was available.<br><br>

</dd>
<dt><big><a name="RawRadixTree"></a>struct <u>RawRadixTree</u>(Value = void);
</big></dt>
<dd>Adaptive radix tree (ART) container storing untyped (raw) keys.
<br><br>
In set-case (<pre style="display:inline;" class="d_inline_code">Value</pre> is <pre style="display:inline;" class="d_inline_code">void</pre>) this container contains specific memory
    optimizations for representing a set pointers or integral types (of fixed
    length).
<br><br>

    Radix-trees are suitable for storing ordered sets/maps with variable-length
    keys and provide completion of all its keys matching a given
    key-prefix. This enables, for instance, efficient storage and retrieval of
    large sets of long URLs with high probability of sharing a common prefix,
    typically a domain and path.
<br><br>

    Branch packing of leaves is more efficient when <pre style="display:inline;" class="d_inline_code">Key.sizeof</pre> is fixed, that
    is, the member <pre style="display:inline;" class="d_inline_code">hasFixedKeyLength</pre> returns <pre style="display:inline;" class="d_inline_code">true</pre>.
<br><br>

    For optimal performance, the individual bit-chunks should be arranged
    starting with most sparse chunks first. For integers this means most
    significant chunk (byte) first. This includes IEEE-compliant floating point
    numbers.
<br><br>

    For a good introduction to adaptive radix trees (ART) see 

<br><br>
<b>See Also:</b><br>


<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>

<br><br>
<b>See Also:</b><br>
<br><br>

<dl><dt><big><a name="RawRadixTree.hasValue"></a>alias <u>hasValue</u> = isValue;
</big></dt>
<dd>Is <pre style="display:inline;" class="d_inline_code">true</pre> if this tree stores values of type <pre style="display:inline;" class="d_inline_code">Value</pre> along with keys. In
            other words: <pre style="display:inline;" class="d_inline_code">this</pre> is a <i>map</i> rather than a <i>set</i>.<br><br>

</dd>
<dt><big><a name="RawRadixTree.dup"></a>@trusted typeof(this) <u>dup</u>();
</big></dt>
<dd>Returns a duplicate of this tree if present.
            Shallowly duplicates the values in the map case.<br><br>

</dd>
<dt><big><a name="RawRadixTree.clear"></a>@nogc void <u>clear</u>();
</big></dt>
<dd>Removes all contents (elements).<br><br>

</dd>
<dt><big><a name="RawRadixTree.prefix"></a>inout inout(Node) <u>prefix</u>(UKey <i>keyPrefix</i>, out UKey <i>keyPrefixRest</i>);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code">key</pre> is stored, <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.<br><br>

</dd>
<dt><big><a name="RawRadixTree.matchCommonPrefix"></a>inout inout(Node) <u>matchCommonPrefix</u>(UKey <i>key</i>, out UKey <i>keyRest</i>);
</big></dt>
<dd>Lookup deepest node having whose <i>key</i> starts with <pre style="display:inline;" class="d_inline_code"><i>key</i></pre>.<br><br>

</dd>
<dt><big><a name="RawRadixTree.contains"></a>inout inout(Value*) <u>contains</u>(UKey <i>key</i>);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code"><i>key</i></pre> is stored, <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.<br><br>

</dd>
<dt><big><a name="RawRadixTree.insert"></a>Node <u>insert</u>(UKey <i>key</i>, in Value <i>value</i>, out ElementRef <i>elementRef</i>);
</big></dt>
<dd>Insert <pre style="display:inline;" class="d_inline_code"><i>key</i></pre> into <pre style="display:inline;" class="d_inline_code">this</pre> tree.<br><br>

</dd>
<dt><big><a name="RawRadixTree.empty"></a>const bool <u>empty</u>();
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff tree is <u>empty</u> (no elements stored).<br><br>

</dd>
<dt><big><a name="RawRadixTree.length"></a>const size_t <u>length</u>();
</big></dt>
<dd><b>Returns:</b><br>
number of elements stored.<br><br>

</dd>
<dt><big><a name="RawRadixTree.rangeRefCount"></a>const RefCount <u>rangeRefCount</u>();
</big></dt>
<dd>Get number of <pre style="display:inline;" class="d_inline_code">Range</pre>-instances that currently refer to <pre style="display:inline;" class="d_inline_code">_rcStore.root</pre> of <pre style="display:inline;" class="d_inline_code">this</pre> tree.<br><br>

</dd>
<dt><big><a name="RawRadixTree.refCount"></a>const RefCount <u>refCount</u>();
</big></dt>
<dd>Reference count.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="toFixedRawKey"></a>@trusted UKey <u>toFixedRawKey</u>(TypedKey)(in TypedKey <i>typedKey</i>, UKey <i>preallocatedFixedUKey</i>);
</big></dt>
<dd>Remap fixed-length typed key <pre style="display:inline;" class="d_inline_code"><i>typedKey</i></pre> to raw (untyped) key of type <pre style="display:inline;" class="d_inline_code">UKey</pre>.
    TODO use DIP-1000<br><br>

</dd>
<dt><big><a name="toRawKey"></a>@trusted UKey <u>toRawKey</u>(TypedKey)(in TypedKey <i>typedKey</i>, ref CopyingArray!Ix <i>rawUKey</i>) if (isTrieableKeyType!TypedKey);
</big></dt>
<dd>Remap typed key <pre style="display:inline;" class="d_inline_code"><i>typedKey</i></pre> to raw (untyped) key of type <pre style="display:inline;" class="d_inline_code">UKey</pre>.
    TODO use DIP-1000<br><br>

</dd>
<dt><big><a name="toTypedKey"></a>@trusted inout(TypedKey) <u>toTypedKey</u>(TypedKey)(inout(Ix)[] <i>ukey</i>) if (isTrieableKeyType!TypedKey);
</big></dt>
<dd>Remap raw untyped key <pre style="display:inline;" class="d_inline_code"><i>ukey</i></pre> to typed key of type <pre style="display:inline;" class="d_inline_code">TypedKey</pre>.<br><br>

</dd>
<dt><big><a name="RadixTree"></a>struct <u>RadixTree</u>(Key, Value) if (allSatisfy!(isTrieableKeyType, Key));
</big></dt>
<dd>Radix-Tree with key of type <pre style="display:inline;" class="d_inline_code">Key</pre> and value of type <pre style="display:inline;" class="d_inline_code">Value</pre> (if non-<pre style="display:inline;" class="d_inline_code">void</pre>).<br><br>

<dl><dt><big><a name="RadixTree.insert"></a>@nogc bool <u>insert</u>(in Key <i>key</i>, in Value <i>value</i>);
</big></dt>
<dd>Insert <pre style="display:inline;" class="d_inline_code"><i>key</i></pre>.
<br><br>
<b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code"><i>key</i></pre> wasn't previously added, <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.<br><br>

</dd>
<dt><big><a name="RadixTree.contains"></a>inout @nogc inout(Value*) <u>contains</u>(in Key <i>key</i>);
</big></dt>
<dd><b>Returns:</b><br>
pointer to value if <pre style="display:inline;" class="d_inline_code"><i>key</i></pre> is contained in set, <b>null</b> otherwise.<br><br>

</dd>
<dt><big><a name="RadixTree.opBinaryRight"></a>inout auto <u>opBinaryRight</u>(string op)(in Key <i>key</i>) if (op == "in");
</big></dt>
<dd>Supports <b><pre style="display:inline;" class="d_inline_code">Key</pre> in <pre style="display:inline;" class="d_inline_code">this</pre></b> syntax.<br><br>

</dd>
<dt><big><a name="RadixTree.prefix"></a>auto <u>prefix</u>(Key <i>keyPrefix</i>);
</big></dt>
<dd>Get range over elements whose key starts with <pre style="display:inline;" class="d_inline_code"><i>keyPrefix</i></pre>.
        The element equal to <pre style="display:inline;" class="d_inline_code"><i>keyPrefix</i></pre> is return as an empty instance of the type.<br><br>

</dd>
<dt><big><a name="RadixTree.upperBound"></a>auto <u>upperBound</u>(Key <i>key</i>);
</big></dt>
<dd>This function searches with policy <pre style="display:inline;" class="d_inline_code">sp</pre> to find the largest right subrange
        on which pred(value, x) is <b>true</b> for all x (e.g., if pred is "less than",
        returns the portion of the range with elements strictly greater than
        value).
        TODO Add template param (SearchPolicy sp)
<br><br>
TODO replace <pre style="display:inline;" class="d_inline_code">matchCommonPrefix</pre> with something more clever directly
        finds the next element after rawKey and returns a TreeRange at that point<br><br>

</dd>
<dt><big><a name="RadixTree.byKey"></a>auto <u>byKey</u>();
</big></dt>
<dd>Get range of map keys.<br><br>

</dd>
<dt><big><a name="RadixTree.byValue"></a>auto <u>byValue</u>();
</big></dt>
<dd>Get range of map values.<br><br>

</dd>
<dt><big><a name="RadixTree.dup"></a>typeof(this) <u>dup</u>();
</big></dt>
<dd>Returns a duplicate of this tree.
        Shallowly duplicates the values in the map case.<br><br>

</dd>
<dt><big><a name="RadixTree.print"></a>const @safe void <u>print</u>();
</big></dt>
<dd>Print <pre style="display:inline;" class="d_inline_code">this</pre> tree.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="MutableKey"></a>template <u>MutableKey</u>(Key)</big></dt>
<dd>Keys are stored in a way that they can't be accessed by reference so we
    allow array (and string) keys to be of mutable type.<br><br>

</dd>
<dt><big><a name="radixTreeSet"></a>@nogc auto <u>radixTreeSet</u>(Key)();
</big></dt>
<dd>Instantiator for the set-version of <pre style="display:inline;" class="d_inline_code">RadixTree</pre> where value-type is <pre style="display:inline;" class="d_inline_code">void</pre> (unused).<br><br>

</dd>
<dt><big><a name="radixTreeSetGrowOnly"></a>@nogc auto <u>radixTreeSetGrowOnly</u>(Key)();
</big></dt>
<dd>Wrapper for a grow-only variant of <pre style="display:inline;" class="d_inline_code">radixTreeSet</pre>.<br><br>

</dd>
<dt><big><a name="radixTreeMap"></a>auto <u>radixTreeMap</u>(Key, Value)();
</big></dt>
<dd>Instantiator for the map-version of <pre style="display:inline;" class="d_inline_code">RadixTree</pre> where value-type is <pre style="display:inline;" class="d_inline_code">Value</pre>.<br><br>

</dd>
<dt><big><a name="radixTreeMapGrowOnly"></a>auto <u>radixTreeMapGrowOnly</u>(Key, Value)();
</big></dt>
<dd>Wrapper for a grow-only variant of <pre style="display:inline;" class="d_inline_code">radixTreeMap</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>version</font>(enterSingleInfiniteMemoryLeakTest)
{
    <font color=blue>while</font> (<font color=blue>true</font>)
    {
        checkNumeric!(<font color=blue>bool</font>, <font color=blue>float</font>, <font color=blue>double</font>,
                      <font color=blue>long</font>, <font color=blue>int</font>, <font color=blue>short</font>, <font color=blue>byte</font>,
                      <font color=blue>ulong</font>, <font color=blue>uint</font>, <font color=blue>ushort</font>, <font color=blue>ubyte</font>);
    }
}
<font color=blue>else</font>
{
    checkNumeric!(<font color=blue>bool</font>, <font color=blue>float</font>, <font color=blue>double</font>,
                  <font color=blue>long</font>, <font color=blue>int</font>, <font color=blue>short</font>, <font color=blue>byte</font>,
                  <font color=blue>ulong</font>, <font color=blue>uint</font>, <font color=blue>ushort</font>, <font color=blue>ubyte</font>);
}
</pre>
<br><br><b>Examples:</b><br>
exercise all switch-cases in <pre style="display:inline;" class="d_inline_code">RawRadixTree.prefixAt()</pre>
<pre class="d_code">
<font color=blue>import</font> std.algorithm : equal;
<font color=blue>alias</font> Key = string;
<font color=blue>auto</font> set = radixTreeSet!(Key);

set.clear();
set.insert(<font color=red>`-----1`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----2`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`2`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----3`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`2`</font>, <font color=red>`3`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----4`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`2`</font>, <font color=red>`3`</font>, <font color=red>`4`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----5`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`2`</font>, <font color=red>`3`</font>, <font color=red>`4`</font>, <font color=red>`5`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----6`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`2`</font>, <font color=red>`3`</font>, <font color=red>`4`</font>, <font color=red>`5`</font>, <font color=red>`6`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----7`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`2`</font>, <font color=red>`3`</font>, <font color=red>`4`</font>, <font color=red>`5`</font>, <font color=red>`6`</font>, <font color=red>`7`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----8`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`2`</font>, <font color=red>`3`</font>, <font color=red>`4`</font>, <font color=red>`5`</font>, <font color=red>`6`</font>, <font color=red>`7`</font>, <font color=red>`8`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----____`</font>).empty);
set.insert(<font color=red>`-----11`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`11`</font>, <font color=red>`2`</font>, <font color=red>`3`</font>, <font color=red>`4`</font>, <font color=red>`5`</font>, <font color=red>`6`</font>, <font color=red>`7`</font>, <font color=red>`8`</font>]));
set.insert(<font color=red>`-----22`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`11`</font>, <font color=red>`2`</font>, <font color=red>`22`</font>, <font color=red>`3`</font>, <font color=red>`4`</font>, <font color=red>`5`</font>, <font color=red>`6`</font>, <font color=red>`7`</font>, <font color=red>`8`</font>]));
set.insert(<font color=red>`-----33`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`11`</font>, <font color=red>`2`</font>, <font color=red>`22`</font>, <font color=red>`3`</font>, <font color=red>`33`</font>, <font color=red>`4`</font>, <font color=red>`5`</font>, <font color=red>`6`</font>, <font color=red>`7`</font>, <font color=red>`8`</font>]));
set.insert(<font color=red>`-----44`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1`</font>, <font color=red>`11`</font>, <font color=red>`2`</font>, <font color=red>`22`</font>, <font color=red>`3`</font>, <font color=red>`33`</font>, <font color=red>`4`</font>, <font color=red>`44`</font>, <font color=red>`5`</font>, <font color=red>`6`</font>, <font color=red>`7`</font>, <font color=red>`8`</font>]));

set.clear();
set.insert(<font color=red>`-----11`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`11`</font>]));
set.insert(<font color=red>`-----22`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`11`</font>, <font color=red>`22`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----___`</font>).empty);

set.clear();
set.insert(<font color=red>`-----111`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`111`</font>]));
set.insert(<font color=red>`-----122`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`111`</font>, <font color=red>`122`</font>]));
set.insert(<font color=red>`-----133`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`111`</font>, <font color=red>`122`</font>, <font color=red>`133`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----1`</font>).equal([<font color=red>`11`</font>, <font color=red>`22`</font>, <font color=red>`33`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----1_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----1___`</font>).empty);

set.clear();
set.insert(<font color=red>`-----1111`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`1111`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----___`</font>).empty);

set.clear();
set.insert(<font color=red>`-----11111`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`11111`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----___`</font>).empty);
set.insert(<font color=red>`-----12222`</font>);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----`</font>).equal([<font color=red>`11111`</font>, <font color=red>`12222`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----___`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----12`</font>).equal([<font color=red>`222`</font>]));
<font color=blue>assert</font>(set.prefix(<font color=red>`-----12_`</font>).empty);
<font color=blue>assert</font>(set.prefix(<font color=red>`-----12____`</font>).empty);
</pre>
<br><br><b>Examples:</b><br>
test floating-point key range sortedness
<pre class="d_code">
<font color=blue>alias</font> T = <font color=blue>double</font>;

<font color=blue>auto</font> set = radixTreeSet!(T);

<font color=blue>import</font> std.range: isForwardRange;
<font color=blue>static</font> <font color=blue>assert</font>(isForwardRange!(<font color=blue>typeof</font>(set[])));

set.insert(-1.1e6);
set.insert(-2.2e9);
set.insert(-1.1);
set.insert(+2.2);
set.insert(T.max);
set.insert(-T.max);
set.insert(-3.3);
set.insert(-4.4);
set.insert(+4.4);
set.insert(+3.3);
set.insert(+1.1e6);
set.insert(+2.2e9);

<font color=blue>import</font> std.algorithm.sorting : isSorted;
<font color=blue>assert</font>(set[].isSorted);
</pre>
<br><br>
</dd>
<dt><big><a name="showStatistics"></a>void <u>showStatistics</u>(RT)(ref const RT <i>tree</i>);
</big></dt>
<dd>Calculate and print statistics of <pre style="display:inline;" class="d_inline_code"><i>tree</i></pre>.<br><br>
<b>Examples:</b><br>
test map from <pre style="display:inline;" class="d_inline_code">uint</pre> to values of type <pre style="display:inline;" class="d_inline_code">double</pre>
<pre class="d_code">
<font color=blue>alias</font> Key = <font color=blue>uint</font>;
<font color=blue>alias</font> Value = <font color=blue>uint</font>;

<font color=blue>auto</font> map = radixTreeMap!(Key, Value);
<font color=blue>assert</font>(map.empty);

<font color=blue>static</font> <font color=blue>assert</font>(map.hasValue);

<font color=blue>static</font> Value keyToValue(Key key) @safe <font color=blue>pure</font> <font color=blue>nothrow</font> @nogc { <font color=blue>return</font> <font color=blue>cast</font>(Value)((key + 1)*radix); }

<font color=blue>foreach</font> (<font color=blue>const</font> i; 0 .. SparseLeaf1!Value.maxCapacity)
{
    <font color=blue>assert</font>(!map.contains(i));
    <font color=blue>assert</font>(map.length == i);
    map[i] = keyToValue(i);
    <font color=blue>assert</font>(map.contains(i));
    <font color=blue>assert</font>(*map.contains(i) == keyToValue(i));
    <font color=blue>assert</font>(i <font color=blue>in</font> map);
    <font color=blue>assert</font>(*(i <font color=blue>in</font> map) == keyToValue(i));
    <font color=blue>assert</font>(map.length == i + 1);
}

<font color=blue>foreach</font> (<font color=blue>const</font> i; SparseLeaf1!Value.maxCapacity .. radix)
{
    <font color=blue>assert</font>(!map.contains(i));
    <font color=blue>assert</font>(map.length == i);
    map[i] = keyToValue(i);
    <font color=blue>assert</font>(map.contains(i));
    <font color=blue>assert</font>(*map.contains(i) == keyToValue(i));
    <font color=blue>assert</font>(i <font color=blue>in</font> map);
    <font color=blue>assert</font>(*(i <font color=blue>in</font> map) == keyToValue(i));
    <font color=blue>assert</font>(map.length == i + 1);
}

<font color=blue>assert</font>(map.rangeRefCount == 0);

<font color=green>// test range
</font>size_t i = 0;
<font color=blue>foreach</font> (<font color=blue>const</font> elt; map[])
{
    <font color=blue>assert</font>(map.rangeRefCount == 1);
    {
        <font color=blue>auto</font> mapRange = map[];
        <font color=blue>assert</font>(map.rangeRefCount == 2);
    }
    <font color=blue>assert</font>(map.rangeRefCount == 1);

    <font color=blue>const</font> Key key = elt[0];
    <font color=blue>const</font> Value value = elt[1];

    <font color=blue>assert</font>(key == i);
    <font color=blue>assert</font>(value == keyToValue(<font color=blue>cast</font>(Key)i)); <font color=green>// TODO use typed key instead of cast(Key)
</font>
    ++i;
}

<font color=blue>assert</font>(map.rangeRefCount == 0);
</pre>
<br><br>
</dd>
<dt><big><a name="testString"></a>auto <u>testString</u>(Keys...)(size_t <i>count</i>, uint <i>maxLength</i>) if (Keys.length &gt;= 1);
</big></dt>
<dd>Check string types in <pre style="display:inline;" class="d_inline_code">Keys</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<u>testString</u>!(string)(512, 8);
<u>testString</u>!(string)(2^^18, 2^^5);
</pre>
<br><br><b>Examples:</b><br>
test map to values of type <pre style="display:inline;" class="d_inline_code">bool</pre>
<pre class="d_code">
<font color=blue>alias</font> Key = <font color=blue>uint</font>;
<font color=blue>alias</font> Value = <font color=blue>bool</font>;

<font color=blue>auto</font> map = radixTreeMap!(Key, Value);
<font color=blue>assert</font>(map.empty);

<font color=blue>static</font> <font color=blue>assert</font>(map.hasValue);
map.insert(Key.init, Value.init);
</pre>
<br><br><b>Examples:</b><br>
test packing of set elements
<pre class="d_code">
<font color=blue>auto</font> set = radixTreeSet!(<font color=blue>ulong</font>);
<font color=blue>enum</font> N = HeptLeaf1.capacity;

<font color=blue>foreach</font> (<font color=blue>const</font> i; 0 .. N)
{
    <font color=blue>assert</font>(!set.contains(i));

    <font color=blue>assert</font>(set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=blue>assert</font>(!set.insert(i));
    <font color=blue>assert</font>(set.contains(i));
}

<font color=blue>foreach</font> (<font color=blue>const</font> i; N .. 256)
{
    <font color=blue>assert</font>(!set.contains(i));

    <font color=blue>assert</font>(set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=blue>assert</font>(!set.insert(i));
    <font color=blue>assert</font>(set.contains(i));
}

<font color=blue>foreach</font> (<font color=blue>const</font> i; 256 .. 256 + N)
{
    <font color=blue>assert</font>(!set.contains(i));

    <font color=blue>assert</font>(set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=blue>assert</font>(!set.insert(i));
    <font color=blue>assert</font>(set.contains(i));
}

<font color=blue>foreach</font> (<font color=blue>const</font> i; 256 + N .. 256 + 256)
{
    <font color=blue>assert</font>(!set.contains(i));

    <font color=blue>assert</font>(set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=blue>assert</font>(!set.insert(i));
    <font color=blue>assert</font>(set.contains(i));
}
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> set = radixTreeSet!(<font color=blue>ubyte</font>);
<font color=blue>alias</font> Set = <font color=blue>typeof</font>(set);

<font color=blue>foreach</font> (<font color=blue>const</font> i; 0 .. HeptLeaf1.capacity)
{
    <font color=blue>assert</font>(!set.contains(i));

    <font color=blue>assert</font>(set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=blue>assert</font>(!set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=green>// debug assert(set.heapAllocationBalance == 0);
</font>    <font color=blue>const</font> rootRef = set.getRoot.peek!(HeptLeaf1);
    <font color=blue>assert</font>(rootRef);
}

<font color=blue>foreach</font> (<font color=blue>const</font> i; HeptLeaf1.capacity .. 256)
{
    <font color=blue>assert</font>(!set.contains(i));

    <font color=blue>assert</font>(set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=blue>assert</font>(!set.insert(i));
    <font color=blue>assert</font>(set.contains(i));

    <font color=green>// debug assert(set.heapAllocationBalance == 1);
</font>    <font color=green>// const rootRef = set.getRoot.peek!(SparseLeaf1!void*);
</font>    <font color=green>// assert(rootRef);
</font>}

<font color=green>// const rootRef = set.getRoot.peek!(SparseLeaf1!void*);
</font><font color=green>// assert(rootRef);
</font>
<font color=green>// const root = *rootRef;
</font><font color=green>// assert(!root.empty);
</font><font color=green>// assert(root.full);
</font></pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.meta : AliasSeq;
<font color=blue>foreach</font> (T; AliasSeq!(<font color=blue>ushort</font>, <font color=blue>uint</font>))
{
    <font color=blue>auto</font> set = radixTreeSet!(T);
    <font color=blue>alias</font> Set = <font color=blue>typeof</font>(set);

    <font color=blue>foreach</font> (<font color=blue>const</font> i; 0 .. 256)
    {
        <font color=blue>assert</font>(!set.contains(i));

        <font color=blue>assert</font>(set.insert(i));
        <font color=blue>assert</font>(set.contains(i));

        <font color=blue>assert</font>(!set.insert(i));
        <font color=blue>assert</font>(set.contains(i));
    }

    <font color=green>// 256
</font>    <font color=blue>assert</font>(!set.contains(256));

    <font color=blue>assert</font>(set.insert(256));
    <font color=blue>assert</font>(set.contains(256));

    <font color=blue>assert</font>(!set.insert(256));
    <font color=blue>assert</font>(set.contains(256));

    <font color=green>// 257
</font>    <font color=blue>assert</font>(!set.contains(257));

    <font color=blue>assert</font>(set.insert(257));
    <font color=blue>assert</font>(set.contains(257));

    <font color=blue>assert</font>(!set.insert(257));
    <font color=blue>assert</font>(set.contains(257));

    <font color=blue>const</font> rootRef = set.getRoot.peek!(Set.DefaultBranchType*);
    <font color=blue>assert</font>(rootRef);
    <font color=blue>const</font> root = *rootRef;
    <font color=blue>assert</font>(root.prefix.length == T.sizeof - 2);

}
</pre>
<br><br>
</dd>
<dt><big><a name="testWords"></a>void <u>testWords</u>(Value)();
</big></dt>
<dd>Create a set of words from /usr/share/dict/words<br><br>

</dd>
<dt><big><a name="checkNumeric"></a>auto <u>checkNumeric</u>(Keys...)() if (Keys.length &gt;= 1);
</big></dt>
<dd>Check correctness when span is <pre style="display:inline;" class="d_inline_code">span</pre> and for each <pre style="display:inline;" class="d_inline_code">Key</pre> in <pre style="display:inline;" class="d_inline_code">Keys</pre>.<br><br>

</dd>
<dt><big><a name="benchmark"></a>void <u>benchmark</u>()();
</big></dt>
<dd>Benchmark performance and memory usage when span is <pre style="display:inline;" class="d_inline_code">span</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>struct</font> S { <font color=blue>int</font> x; }

<font color=blue>alias</font> Key = S;
<font color=blue>auto</font> set = radixTreeSet!(Key);

<font color=blue>assert</font>(!set.contains(S(43)));

<font color=blue>assert</font>(set.insert(S(43)));
<font color=blue>assert</font>(set.contains(S(43)));

<font color=blue>assert</font>(!set.insert(S(43)));
<font color=blue>assert</font>(set.contains(S(43)));
</pre>
<br><br>
</dd>
<dt><big><a name="iota"></a>template <u>iota</u>(size_t from, size_t to) if (from &lt;= to)</big></dt>
<dd>Static Iota.
    TODO Move to Phobos std.range.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
