<html><head>
        <!-- Generated by Ddoc from /home/per/Work/phobos-next/src/typecons_ex.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>typecons_ex</title>
        </head><body>
        <h1>typecons_ex</h1>
<br><br>
<dl><dt><big><a name="nullable"></a>auto <u>nullable</u>(T)(T <i>a</i>);
</big></dt>
<dd>Instantiator for <pre style="display:inline;" class="d_inline_code">Nullable</pre>.<br><br>

</dd>
<dt><big><a name="nullable.2"></a>auto <u>nullable</u>(alias nullValue, T)(T <i>value</i>) if (is(typeof(nullValue) == T));
</big></dt>
<dd>Instantiator for <pre style="display:inline;" class="d_inline_code">Nullable</pre>.<br><br>

</dd>
<dt><big><a name="nullableRef"></a>pure nothrow @safe auto <u>nullableRef</u>(T)(T* <i>a</i>);
</big></dt>
<dd>Instantiator for <pre style="display:inline;" class="d_inline_code">NullableRef</pre>.<br><br>

</dd>
<dt><big><a name="New"></a>template <u>New</u>(T) if (is(T == class))</big></dt>
<dd>See also: http://forum.dlang.org/thread/jwdbjlobbilowlnpdzzo@forum.dlang.org<br><br>

</dd>
<dt><big><a name="isCastableTo"></a>enum auto <u>isCastableTo</u>(T, U);
</big></dt>
<dd>Check if <pre style="display:inline;" class="d_inline_code">T</pre> is castable to <pre style="display:inline;" class="d_inline_code">U</pre>.<br><br>

</dd>
<dt><big><a name="isIndexableBy"></a>enum auto <u>isIndexableBy</u>(R, I);
</big></dt>
<dd>Check if <pre style="display:inline;" class="d_inline_code">R</pre> is indexable by <pre style="display:inline;" class="d_inline_code">I</pre>.<br><br>

</dd>
<dt><big><a name="isIndexableBy.2"></a>enum auto <u>isIndexableBy</u>(R, alias I);
</big></dt>
<dd>Check if <pre style="display:inline;" class="d_inline_code">R</pre> is indexable by <pre style="display:inline;" class="d_inline_code">I</pre>.<br><br>

</dd>
<dt><big><a name="genOps"></a>template <u>genOps</u>(I)</big></dt>
<dd>Generate <pre style="display:inline;" class="d_inline_code">opIndex</pre> and <pre style="display:inline;" class="d_inline_code">opSlice</pre>.<br><br>

</dd>
<dt><big><a name="genTrustedUncheckedOps"></a>template <u>genTrustedUncheckedOps</u>(I)</big></dt>
<dd>Generate <pre style="display:inline;" class="d_inline_code">opIndex</pre> and <pre style="display:inline;" class="d_inline_code">opSlice</pre>.<br><br>

</dd>
<dt><big><a name="IndexedBy"></a>struct <u>IndexedBy</u>(R, I) if (isIndexableBy!(R, I));
</big></dt>
<dd>Wrapper for <pre style="display:inline;" class="d_inline_code">R</pre> with Type-Safe <pre style="display:inline;" class="d_inline_code">I</pre>-Indexing.
    See also: http://forum.dlang.org/thread/gayfjaslyairnzrygbvh@forum.dlang.org#post-gayfjaslyairnzrygbvh:40forum.dlang.org
<br><br>
    TODO Merge with https://github.com/rcorre/enumap
<br><br>

    TODO Use std.range.indexed when I is an enum with non-contigious
    enumerators. Perhaps use among aswell.
<br><br>

    TODO Rename to something more concise such as [Bb]y.
<br><br>

    TODO Allow <pre style="display:inline;" class="d_inline_code">I</pre> to be a string and if so derive <pre style="display:inline;" class="d_inline_code">Index</pre> to be that string.
<br><br>

    TODO Support R being a static array:
         - If I is an enum its number of elements should match R.length<br><br>

<dl><dt><big><a name="IndexedBy.Index"></a>alias <u>Index</u> = I;
</big></dt>
<dd>indexing type<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="IndexedArray"></a>struct <u>IndexedArray</u>(E, I) if (isIndex!I);
</big></dt>
<dd>Static Array of ElementType <pre style="display:inline;" class="d_inline_code">E</pre> indexed by <pre style="display:inline;" class="d_inline_code">I</pre>.
    TODO assert that <pre style="display:inline;" class="d_inline_code">I</pre> is continuous if it is a <pre style="display:inline;" class="d_inline_code">enum</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> N = 7;
<font color=blue>enum</font> E { x = 0, y = 1, z = 2}
<font color=blue>alias</font> A = <u>IndexedArray</u>!(size_t, E);
<font color=blue>static</font> <font color=blue>assert</font>(A.sizeof == 3*size_t.sizeof);
A x;
x[E.x] = 1;
x[E.y] = 2;
x[E.z] = 3;
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { x[1] = 3; })); <font color=green>// no integer indexing
</font></pre>
<br><br>
<dl><dt><big><a name="IndexedArray.Index"></a>alias <u>Index</u> = I;
</big></dt>
<dd>indexing type<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="indexedBy"></a>auto <u>indexedBy</u>(I, R)(R <i>range</i>) if (isIndexableBy!(R, I));
</big></dt>
<dd>Instantiator for <pre style="display:inline;" class="d_inline_code">IndexedBy</pre>.<br><br>

</dd>
<dt><big><a name="StrictlyIndexed"></a>template <u>StrictlyIndexed</u>(R) if (isArray!R)</big></dt>
<dd>Construct wrapper type for `R' which is strictly indexed with type
    <pre style="display:inline;" class="d_inline_code">R.Index</pre>.<br><br>

</dd>
<dt><big><a name="indexedBy.2"></a>auto <u>indexedBy</u>(string I, R)(R <i>range</i>) if (isArray!R &amp;&amp; I != "IndexTypeName");
</big></dt>
<dd>Instantiator for <pre style="display:inline;" class="d_inline_code">IndexedBy</pre>.<br><br>

</dd>
<dt><big><a name="strictlyIndexed"></a>auto <u>strictlyIndexed</u>(R)(R <i>range</i>) if (isArray!R);
</big></dt>
<dd>Instantiator for <pre style="display:inline;" class="d_inline_code">StrictlyIndexed</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> m = 3;
<font color=blue>int</font>[m] x = [11, 22, 33];
<font color=blue>auto</font> y = x.<u>strictlyIndexed</u>;

<font color=blue>alias</font> Y = <font color=blue>typeof</font>(y);

<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(y.findIndex(11).index) == Y.Index));

<font color=blue>assert</font>(y.findIndex(11).exists);
<font color=blue>assert</font>(y.findIndex(22).exists);
<font color=blue>assert</font>(y.findIndex(33).exists);

<font color=blue>if</font> (<font color=blue>auto</font> hit = y.findIndex(11)) { <font color=blue>assert</font>(hit.index == 0); } <font color=blue>else</font> { <font color=blue>assert</font>(<font color=blue>false</font>); }
<font color=blue>if</font> (<font color=blue>auto</font> hit = y.findIndex(22)) { <font color=blue>assert</font>(hit.index == 1); } <font color=blue>else</font> { <font color=blue>assert</font>(<font color=blue>false</font>); }
<font color=blue>if</font> (<font color=blue>auto</font> hit = y.findIndex(33)) { <font color=blue>assert</font>(hit.index == 2); } <font color=blue>else</font> { <font color=blue>assert</font>(<font color=blue>false</font>); }

<font color=blue>assert</font>(!y.findIndex(44));
<font color=blue>assert</font>(!y.findIndex(55));

<font color=blue>assert</font>(!y.findIndex(44).exists);
<font color=blue>assert</font>(!y.findIndex(55).exists);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> N = 7;
<font color=blue>alias</font> T = StrictlyIndexed!(size_t[N]); <font color=green>// static array
</font><font color=blue>static</font> <font color=blue>assert</font>(T.sizeof == N*size_t.sizeof);
<font color=blue>import</font> modulo : Mod, mod;

T x;

x[Mod!N(1)] = 11;
x[1.mod!N] = 11;
<font color=blue>assert</font>(x[1.mod!N] == 11);

x.at!1 = 12;
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { x.at!N; }));
<font color=blue>assert</font>(x.at!1 == 12);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font>[3] x = [1, 2, 3];

<font color=green>// sample index
</font><font color=blue>struct</font> Index(T = size_t)
    <font color=blue>if</font> (isUnsigned!T)
{
    <font color=blue>this</font>(T i) { <font color=blue>this</font>._i = i; }
    T opCast(U : T)() <font color=blue>const</font> { <font color=blue>return</font> _i; }
    <font color=blue>private</font> T _i = 0;
}
<font color=blue>alias</font> J = Index!size_t;

<font color=blue>enum</font> E { e0, e1, e2 }

<font color=blue>with</font> (E)
{
    <font color=blue>auto</font> xb = x.indexedBy!<font color=blue>ubyte</font>;
    <font color=blue>auto</font> xi = x.indexedBy!<font color=blue>uint</font>;
    <font color=blue>auto</font> xj = x.indexedBy!J;
    <font color=blue>auto</font> xe = x.indexedBy!E;
    <font color=blue>auto</font> xf = x.<u>strictlyIndexed</u>;

    <font color=blue>auto</font> xs = x.indexedBy!<font color=red>"I"</font>;
    <font color=blue>alias</font> XS = <font color=blue>typeof</font>(xs);
    XS xs_;

    <font color=green>// indexing with correct type
</font>    xb[  0 ] = 11; <font color=blue>assert</font>(xb[  0 ] == 11);
    xi[  0 ] = 11; <font color=blue>assert</font>(xi[  0 ] == 11);
    xj[J(0)] = 11; <font color=blue>assert</font>(xj[J(0)] == 11);
    xe[ e0 ] = 11; <font color=blue>assert</font>(xe[ e0 ] == 11);

    <font color=green>// indexing with wrong type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xb[J(0)] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xi[J(0)] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xj[  0 ] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xe[  0 ] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xs[  0 ] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xs_[  0 ] = 11; }));

    <font color=blue>import</font> std.algorithm.comparison : equal;
    <font color=blue>import</font> std.algorithm.iteration : filter;

    <font color=blue>assert</font>(equal(xb[].filter!(a =&gt; a &lt; 11), [2, 3]));
    <font color=blue>assert</font>(equal(xi[].filter!(a =&gt; a &lt; 11), [2, 3]));
    <font color=blue>assert</font>(equal(xj[].filter!(a =&gt; a &lt; 11), [2, 3]));
    <font color=blue>assert</font>(equal(xe[].filter!(a =&gt; a &lt; 11), [2, 3]));
    <font color=green>// assert(equal(xs[].filter!(a =&gt; a &lt; 11), [2, 3]));
</font>}
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [1, 2, 3];

<font color=green>// sample index
</font><font color=blue>struct</font> Index(T = size_t)
    <font color=blue>if</font> (isUnsigned!T)
{
    <font color=blue>this</font>(T ix) { <font color=blue>this</font>._ix = ix; }
    T opCast(U : T)() <font color=blue>const</font> { <font color=blue>return</font> _ix; }
    <font color=blue>private</font> T _ix = 0;
}
<font color=blue>alias</font> J = Index!size_t;

<font color=blue>enum</font> E { e0, e1, e2 }

<font color=blue>with</font> (E)
{
    <font color=blue>auto</font> xb = x.indexedBy!<font color=blue>ubyte</font>;
    <font color=blue>auto</font> xi = x.indexedBy!<font color=blue>uint</font>;
    <font color=blue>auto</font> xj = x.indexedBy!J;
    <font color=blue>auto</font> xe = x.indexedBy!E;

    <font color=green>// indexing with correct type
</font>    xb[  0 ] = 11; <font color=blue>assert</font>(xb[  0 ] == 11);
    xi[  0 ] = 11; <font color=blue>assert</font>(xi[  0 ] == 11);
    xj[J(0)] = 11; <font color=blue>assert</font>(xj[J(0)] == 11);
    xe[ e0 ] = 11; <font color=blue>assert</font>(xe[ e0 ] == 11);

    <font color=green>// slicing with correct type
</font>    xb[  0  ..   1 ] = 12; <font color=blue>assert</font>(xb[  0  ..   1 ] == [12]);
    xi[  0  ..   1 ] = 12; <font color=blue>assert</font>(xi[  0  ..   1 ] == [12]);
    xj[J(0) .. J(1)] = 12; <font color=blue>assert</font>(xj[J(0) .. J(1)] == [12]);
    xe[ e0  ..  e1 ] = 12; <font color=blue>assert</font>(xe[ e0  ..  e1 ] == [12]);

    <font color=green>// indexing with wrong type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xb[J(0)] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xi[J(0)] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xj[  0 ] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xe[  0 ] = 11; }));

    <font color=green>// slicing with wrong type
</font>    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xb[J(0) .. J(0)] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xi[J(0) .. J(0)] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xj[  0  ..   0 ] = 11; }));
    <font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { xe[  0  ..   0 ] = 11; }));

    <font color=blue>import</font> std.algorithm.comparison : equal;
    <font color=blue>import</font> std.algorithm.iteration : filter;

    <font color=blue>assert</font>(equal(xb.filter!(a =&gt; a &lt; 11), [2, 3]));
    <font color=blue>assert</font>(equal(xi.filter!(a =&gt; a &lt; 11), [2, 3]));
    <font color=blue>assert</font>(equal(xj.filter!(a =&gt; a &lt; 11), [2, 3]));
    <font color=blue>assert</font>(equal(xe.filter!(a =&gt; a &lt; 11), [2, 3]));
}
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [1, 2, 3];
<font color=blue>struct</font> I(T = size_t)
{
    <font color=blue>this</font>(T ix) { <font color=blue>this</font>._ix = ix; }
    T opCast(U : T)() <font color=blue>const</font> { <font color=blue>return</font> _ix; }
    <font color=blue>private</font> T _ix = 0;
}
<font color=blue>alias</font> J = I!size_t;
<font color=blue>auto</font> xj = x.indexedBy!J;
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [1, 2, 3];
<font color=blue>struct</font> I(T = size_t)
{
    <font color=blue>private</font> T _ix = 0;
}
<font color=blue>alias</font> J = I!size_t;
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { <font color=blue>auto</font> xj = x.indexedBy!J; }));
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [1, 2, 3];
<font color=blue>import</font> bound : Bound;
<font color=blue>alias</font> B = Bound!(<font color=blue>ubyte</font>, 0, 2);
B b;
<font color=blue>auto</font> c = <font color=blue>cast</font>(size_t)b;
<font color=blue>auto</font> y = x.indexedBy!B;
</pre>
<br><br>
</dd>
<dt><big><a name="makeEnumFromSymbolNames"></a>template <u>makeEnumFromSymbolNames</u>(string prefix = "__", string suffix = "", bool firstUndefined = true, bool useMangleOf = false, Es...) if (Es.length &gt;= 1)</big></dt>
<dd><b>Returns:</b><br>
a <pre style="display:inline;" class="d_inline_code">string</pre> containing the definition of an <pre style="display:inline;" class="d_inline_code">enum</pre> named <pre style="display:inline;" class="d_inline_code">name</pre> and
    with enumerator names given by <pre style="display:inline;" class="d_inline_code">Es</pre>, optionally prepended with <pre style="display:inline;" class="d_inline_code">prefix</pre> and
    appended with <pre style="display:inline;" class="d_inline_code">suffix</pre>.
<br><br>

    TODO Move to Phobos std.typecons<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
