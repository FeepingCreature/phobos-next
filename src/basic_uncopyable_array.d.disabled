module basic_array;

import std.traits : Unqual;

/** Non-copyable variant of `BasicArray`.
 */
struct BasicArray(T,
                       alias Allocator = null, // null means means to qcmeman functions
                       CapacityType = size_t)  // see also https://github.com/izabera/s
    if (!is(Unqual!T == bool) &&             // use `BitArray` instead
        (is(CapacityType == ulong) ||        // 3 64-bit words
         is(CapacityType == uint)))          // 2 64-bit words
{
    import std.range : ElementType, isCopyable;

    pragma(inline, true):

    /// Returns: an array of length `initialLength` with all elements default-initialized to `ElementType.init`.
    static typeof(this) withLength(size_t initialLength) @trusted
    {
        typeof(return) that = void;
        that._basicArray = Super.withLength(initialLength);
        return that;
    }

    /// Construct from element `values`.
    this(U)(U[] values...)
        if (Super.isElementAssignable!U &&
            isCopyable!U)       // prevent accidental move of l-value `values`
    {
        _basicArray = Super(values);
    }

    /// Construct from element(s) `values`.
    this(uint n)(T[n] values...) @trusted
    {
        _basicArray = Super(values);
    }

    /// Construct from range of element `values`.
    pragma(inline)              // DMD cannot inline
    this(R)(R values)
        if (Super.isAssignableFromElementsOfRefIterableStruct!R)
    {
        _basicArray = Super(values);
    }

    /// Construct from uncopyable range of uncopyable `values`.
    this(R)(R values) @trusted
        if (!isCopyable!R &&
            !isCopyable!(ElementType!R) &&
            Super.isElementAssignable!(ElementType!R))
    {
        static assert(0, "TODO implement");
    }

    /** Emplace `thatPtr` with elements moved from `elements`. */
    static ref typeof(this) emplaceWithMovedElements(typeof(this)* thatPtr,
                                                     T[] elements) @system
    {
        Super.emplaceWithMovedElements(&thatPtr._basicArray, elements);
        return *thatPtr;
    }

    @disable this(this);        // no copy construction

    /// Returns: shallow duplicate of `this`.
    static if (isCopyable!T)
    {
        // `MutableThis` mimics behaviour of `dup` for builtin D arrays
        pragma(inline)          // DMD cannot inline
        @property BasicArray!(Unqual!T, Allocator, CapacityType) dup() const @trusted
        {
            return typeof(return)(cast(Unqual!T[])this[]);
        }
    }

    import basic_array : BasicArray;
    alias Super = BasicArray!(T, Allocator, CapacityType);
    Super _basicArray;
    alias _basicArray this;
}

/// construct from uncopyable scalar

version(unittest)
{
    import array_help : s;
}
