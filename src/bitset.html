<html><head>
        <!-- Generated by Ddoc from /home/per/Work/phobos-next/src/bitset.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>bitset</title>
        </head><body>
        <h1>bitset</h1>
Fixed-Sized Bit-Array.
<br><br>
<b>License:</b><br>
.
<br><br>
<b>Authors:</b><br>
<br><br>

<dl><dt><big><a name="BitSet"></a>struct <u>BitSet</u>(uint len, Block = size_t);
</big></dt>
<dd><u>BitSet</u>, a statically sized <pre style="display:inline;" class="d_inline_code">std.bitmanip.BitArray</pre>.
<br><br>
TODO Infer <pre style="display:inline;" class="d_inline_code">Block</pre> from <pre style="display:inline;" class="d_inline_code">len</pre> as is done for <pre style="display:inline;" class="d_inline_code">Bound</pre> and <pre style="display:inline;" class="d_inline_code">Mod</pre>.
    TODO Optimize <pre style="display:inline;" class="d_inline_code">allOnes</pre>, <pre style="display:inline;" class="d_inline_code">allZeros</pre> using intrinsic?<br><br>
<b>Examples:</b><br>
compile-time
<pre class="d_code">
<font color=blue>import</font> nesses: denseness, sparseness;
<font color=blue>import</font> rational : Rational;
<font color=blue>alias</font> Q = Rational!<font color=blue>ulong</font>;

<font color=blue>enum</font> m = 256, n = 256;

<font color=blue>static</font> <font color=blue>assert</font>(<u>BitSet</u>!m.init ==
              <u>BitSet</u>!m.init);
<font color=blue>static</font> <font color=blue>assert</font>(<u>BitSet</u>!m.init.denseness == Q(0, m));
</pre>
<br><br><b>Examples:</b><br>
run-time
<pre class="d_code">
<font color=blue>import</font> std.algorithm : equal;
<font color=blue>import</font> nesses: denseness;
<font color=blue>import</font> rational : Rational;

<font color=blue>alias</font> Q = Rational!<font color=blue>ulong</font>;
<font color=blue>enum</font> m = 256;

<u>BitSet</u>!m b0;

<font color=blue>import</font> modulo : Mod;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(b0.oneIndexes.front()) == Mod!m));

b0[1] = 1;
b0[2] = 1;

b0[m/2 - 11] = 1;
b0[m/2 - 1] = 1;
b0[m/2] = 1;
b0[m/2 + 1] = 1;
b0[m/2 + 11] = 1;

b0[m - 3] = 1;
b0[m - 2] = 1;

<font color=blue>assert</font>(b0.oneIndexes.equal([1, 2,
                            m/2 - 11, m/2 - 1, m/2, m/2 + 1, m/2 + 11,
                            m - 3,
                            m - 2]));
<font color=blue>assert</font>(b0.countOnes == 9);
<font color=blue>assert</font>(b0.denseness == Q(9, m));
</pre>
<br><br><b>Examples:</b><br>
run-time
<pre class="d_code">
<font color=blue>import</font> std.algorithm : equal;
<font color=blue>import</font> nesses: denseness;
<font color=blue>import</font> rational : Rational;

<font color=blue>alias</font> Q = Rational!<font color=blue>ulong</font>;
<font color=blue>enum</font> m = 256;

<u>BitSet</u>!m b0;

<font color=blue>import</font> modulo : Mod;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(b0.oneIndexes.front()) == Mod!m));

b0[0] = 1;
b0[1] = 1;
b0[m/2 - 11] = 1;
b0[m/2 - 1] = 1;
b0[m/2] = 1;
b0[m/2 + 1] = 1;
b0[m/2 + 11] = 1;
b0[m - 2] = 1;
b0[m - 1] = 1;

<font color=blue>assert</font>(b0.oneIndexes.equal([0, 1,
                            m/2 - 11, m/2 - 1, m/2, m/2 + 1, m/2 + 11,
                            m - 2,
                            m - 1]));
<font color=blue>assert</font>(b0.countOnes == 9);
<font color=blue>assert</font>(b0.denseness == Q(9, m));
</pre>
<br><br><b>Examples:</b><br>
run-time
<pre class="d_code">
<font color=blue>import</font> std.algorithm : equal;
<font color=blue>import</font> nesses: denseness;
<font color=blue>import</font> rational : Rational;
<font color=blue>alias</font> Q = Rational!<font color=blue>ulong</font>;

<font color=blue>enum</font> m = 256, n = 256;

<u>BitSet</u>!m[n] b1;
b1[0][0] = 1;
<font color=blue>assert</font>(b1.denseness == Q(1, m*n));

<u>BitSet</u>!m[n][n] b2;
b2[0][0][0] = 1;
b2[0][0][1] = 1;
b2[0][0][4] = 1;
<font color=blue>assert</font>(b2.denseness == Q(3, m*n*n));
</pre>
<br><br><b>Examples:</b><br>
ditto
<pre class="d_code">
<font color=blue>import</font> std.traits : isIterable;
<font color=blue>static</font> <font color=blue>assert</font>(isIterable!(<u>BitSet</u>!256));
</pre>
<br><br><b>Examples:</b><br>
test ubyte access
<pre class="d_code">
<font color=blue>auto</font> b8 = <u>BitSet</u>!(8, <font color=blue>ubyte</font>)();
b8[0] = 1;
b8[1] = 1;
b8[3] = 1;
b8[6] = 1;

<font color=blue>assert</font>(b8.ubytes == [64 + 8 + 2 + 1]);

<font color=blue>alias</font> Ix = b8.Index;
Ix nextIx;

<font color=blue>assert</font>(b8.canFindIndexOf(<font color=blue>true</font>, Ix(0), nextIx));
<font color=blue>assert</font>(nextIx == 0);

<font color=blue>assert</font>(b8.canFindIndexOf(<font color=blue>true</font>, Ix(1), nextIx));
<font color=blue>assert</font>(nextIx == 1);

<font color=blue>assert</font>(b8.canFindIndexOf(<font color=blue>true</font>, Ix(2), nextIx));
<font color=blue>assert</font>(nextIx == 3);

<font color=blue>assert</font>(b8.canFindIndexOf(<font color=blue>true</font>, Ix(3), nextIx));
<font color=blue>assert</font>(nextIx == 3);

<font color=blue>assert</font>(b8.canFindIndexOf(<font color=blue>true</font>, Ix(4), nextIx));
<font color=blue>assert</font>(nextIx == 6);

<font color=blue>assert</font>(!b8.canFindIndexOf(<font color=blue>true</font>, Ix(7), nextIx));
</pre>
<br><br><b>Examples:</b><br>
test all zero and all one predicates
<pre class="d_code">
<font color=blue>static</font> <font color=blue>void</font> test(size_t restCount)()
{
    <font color=blue>enum</font> n = 8*size_t.sizeof + restCount;

    <font color=blue>auto</font> bs = <u>BitSet</u>!(n, size_t)();

    <font color=blue>assert</font>(bs.allZero);
    <font color=blue>assert</font>(!bs.allOne);

    <font color=blue>foreach</font> (<font color=blue>const</font> i; 0 .. n - 1)
    {
        bs[i] = <font color=blue>true</font>;
        <font color=blue>assert</font>(!bs.allZero);
        <font color=blue>assert</font>(!bs.allOne);
    }
    bs[n - 1] = <font color=blue>true</font>;

    <font color=blue>assert</font>(bs.allOne);
}
test!0;
test!1;
test!2;
test!37;
test!62;
test!63;
</pre>
<br><br><b>Examples:</b><br>
ditto
<pre class="d_code">
<font color=blue>import</font> std.format : format;

<font color=blue>const</font> b0_ = <u>BitSet</u>!0([]);
<font color=blue>const</font> b0 = b0_;
<font color=blue>assert</font>(format(<font color=red>"%s"</font>, b0) == <font color=red>"[]"</font>);
<font color=blue>assert</font>(format(<font color=red>"%b"</font>, b0) <font color=blue>is</font> <font color=blue>null</font>);

<font color=blue>const</font> b1_ = <u>BitSet</u>!1([1]);
<font color=blue>const</font> b1 = b1_;
<font color=blue>assert</font>(format(<font color=red>"%s"</font>, b1) == <font color=red>"[1]"</font>);
<font color=blue>assert</font>(format(<font color=red>"%b"</font>, b1) == <font color=red>"1"</font>);

<font color=blue>const</font> b4 = <u>BitSet</u>!4([0, 0, 0, 0]);
<font color=blue>assert</font>(format(<font color=red>"%b"</font>, b4) == <font color=red>"0000"</font>);

<font color=blue>const</font> b8 = <u>BitSet</u>!8([0, 0, 0, 0, 1, 1, 1, 1]);
<font color=blue>assert</font>(format(<font color=red>"%s"</font>, b8) == <font color=red>"[0, 0, 0, 0, 1, 1, 1, 1]"</font>);
<font color=blue>assert</font>(format(<font color=red>"%b"</font>, b8) == <font color=red>"00001111"</font>);

<font color=blue>const</font> b16 = <u>BitSet</u>!16([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);
<font color=blue>assert</font>(format(<font color=red>"%s"</font>, b16) == <font color=red>"[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]"</font>);
<font color=blue>assert</font>(format(<font color=red>"%b"</font>, b16) == <font color=red>"00001111_00001111"</font>);

<font color=blue>const</font> b9 = <u>BitSet</u>!9([1, 0, 0, 0, 0, 1, 1, 1, 1]);
<font color=blue>assert</font>(format(<font color=red>"%b"</font>, b9) == <font color=red>"1_00001111"</font>);

<font color=blue>const</font> b17 = <u>BitSet</u>!17([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);
<font color=blue>assert</font>(format(<font color=red>"%b"</font>, b17) == <font color=red>"1_00001111_00001111"</font>);
</pre>
<br><br><b>Examples:</b><br>
test range
<pre class="d_code">
<font color=blue>static</font> testRange(Block)()
{
    <u>BitSet</u>!(6, Block) bs = [<font color=blue>false</font>, 1, 0, 0, <font color=blue>true</font>, 0];
    bs.put(3, <font color=blue>true</font>);

    <font color=blue>import</font> std.algorithm : equal;

    <font color=blue>assert</font>(bs[0] == <font color=blue>false</font>);
    <font color=blue>assert</font>(bs[1] == <font color=blue>true</font>);
    <font color=blue>assert</font>(bs[2] == <font color=blue>false</font>);
    <font color=blue>assert</font>(bs[3] == <font color=blue>true</font>);
    <font color=blue>assert</font>(bs[4] == <font color=blue>true</font>);
    <font color=blue>assert</font>(bs[5] == <font color=blue>false</font>);

    <font color=blue>assert</font>(bs.at!0 == <font color=blue>false</font>);
    <font color=blue>assert</font>(bs.at!1 == <font color=blue>true</font>);
    <font color=blue>assert</font>(bs.at!2 == <font color=blue>false</font>);
    <font color=blue>assert</font>(bs.at!3 == <font color=blue>true</font>);
    <font color=blue>assert</font>(bs.at!4 == <font color=blue>true</font>);
    <font color=blue>assert</font>(bs.at!5 == <font color=blue>false</font>);

    <font color=green>// test slicing
</font>    <font color=blue>assert</font>(bs[].equal([0, 1, 0, 1, 1, 0]));
    <font color=blue>assert</font>(bs[1 .. 4].equal([1, 0, 1]));

    <font color=blue>auto</font> rs = bs[1 .. 6 - 1]; <font color=green>// TODO Use opDollar
</font>    <font color=blue>assert</font>(rs.length == 4);
    <font color=blue>assert</font>(rs.front == 1);
    <font color=blue>assert</font>(rs.back == 1);

    rs.popFront;
    <font color=blue>assert</font>(rs.front == 0);
    <font color=blue>assert</font>(rs.back == 1);

    rs.popBack;
    <font color=blue>assert</font>(rs.front == 1);
    <font color=blue>assert</font>(rs.back == 1);

    rs.popFront;
    rs.popBack;

    <font color=blue>assert</font>(rs.length == 0);
    <font color=blue>assert</font>(rs.empty);
}

<font color=blue>import</font> std.meta : AliasSeq;
<font color=blue>foreach</font> (Block; AliasSeq!(<font color=blue>ubyte</font>, <font color=blue>ushort</font>, <font color=blue>uint</font>, <font color=blue>ulong</font>, size_t))
{
    testRange!Block;
}
</pre>
<br><br>
<dl><dt><big><a name="BitSet.bitsPerBlock"></a>enum auto <u>bitsPerBlock</u>;
</big></dt>
<dd>Number of bits per <pre style="display:inline;" class="d_inline_code">Block</pre>.<br><br>

</dd>
<dt><big><a name="BitSet.blockCount"></a>enum auto <u>blockCount</u>;
</big></dt>
<dd>Number of <pre style="display:inline;" class="d_inline_code">Block</pre>s.<br><br>

</dd>
<dt><big><a name="BitSet.ubytes"></a>const @trusted const(ubyte)[] <u>ubytes</u>();
</big></dt>
<dd>Data as an array unsigned bytes.<br><br>

</dd>
<dt><big><a name="BitSet.ptr"></a>inout @property inout(Block*) <u>ptr</u>();
</big></dt>
<dd>Get pointer to data blocks.<br><br>

</dd>
<dt><big><a name="BitSet.reset"></a>nothrow @safe void <u>reset</u>();
</big></dt>
<dd>Reset all bits (to zero).<br><br>

</dd>
<dt><big><a name="BitSet.dim"></a>static pure nothrow @nogc @property @safe uint <u>dim</u>();
</big></dt>
<dd>Gets the amount of native words backing this .<br><br>

</dd>
<dt><big><a name="BitSet.length"></a>enum auto <u>length</u>;
</big></dt>
<dd>Number of bits in the .<br><br>

</dd>
<dt><big><a name="BitSet.Range"></a>struct <u>Range</u>;
</big></dt>
<dd>BitSet <u>Range</u>.
<br><br>
TODO Provide opSliceAssign for interopability with range algorithms
        via private static struct member <pre style="display:inline;" class="d_inline_code"><u>Range</u></pre>
<br><br>

        TODO Look at how std.container.array implements this.<br><br>

<dl><dt><big><a name="BitSet.Range.empty"></a>const nothrow bool <u>empty</u>();
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff <pre style="display:inline;" class="d_inline_code">this</pre> is <u>empty</u>.<br><br>

</dd>
<dt><big><a name="BitSet.Range.length"></a>const nothrow size_t <u>length</u>();
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">this</pre> <u>length</u>.<br><br>

</dd>
<dt><big><a name="BitSet.Range.front"></a>const bool <u>front</u>();
</big></dt>
<dd>Get <u>front</u>.<br><br>

</dd>
<dt><big><a name="BitSet.Range.back"></a>const bool <u>back</u>();
</big></dt>
<dd>Get <u>back</u>.<br><br>

</dd>
<dt><big><a name="BitSet.Range.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>Pop front.<br><br>

</dd>
<dt><big><a name="BitSet.Range.popBack"></a>void <u>popBack</u>();
</big></dt>
<dd>Pop back.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="BitSet.opIndex"></a>const pure nothrow @trusted bool <u>opIndex</u>(size_t <i>i</i>);
</big></dt>
<dd>Gets the 'th bit in the .<br><br>

</dd>
<dt><big><a name="BitSet.opIndex.2"></a>const pure nothrow @trusted bool <u>opIndex</u>(ModUInt)(Mod!(len, ModUInt) <i>i</i>) if (isUnsigned!ModUInt);
</big></dt>
<dd>Get the 'th bit in the .
<br><br>
Avoids range-checking because <pre style="display:inline;" class="d_inline_code"><i>i</i></pre> of type is bound to (0 .. len-1).
<br><br>

 Gets the 'th bit in the . No range checking needed.<br><br>

</dd>
<dt><big><a name="BitSet.at"></a>const pure nothrow @trusted bool <u>at</u>(size_t i)() if (i &lt; len);
</big></dt>
<dd>Get the 'th bit in the .
            Statically verifies that i is &lt; BitSet length.
<br><br>
Gets the 'th bit in the . No range checking needed.<br><br>

</dd>
<dt><big><a name="BitSet.put"></a>pure nothrow ref @trusted auto <u>put</u>()(size_t <i>i</i>, bool <i>b</i>);
</big></dt>
<dd>Puts the 'th bit in the  to .<br><br>

</dd>
<dt><big><a name="BitSet.opIndexAssign"></a>pure nothrow @trusted bool <u>opIndexAssign</u>(ModUInt)(bool <i>b</i>, Mod!(len, ModUInt) <i>i</i>) if (isUnsigned!ModUInt);
</big></dt>
<dd>Sets the 'th bit in the . No range checking needed.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
BitSet!2 bs;
bs[0] = <font color=blue>true</font>;
<font color=blue>assert</font>(bs[0]);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.dup"></a>const pure nothrow @nogc @property @safe BitSet <u>dup</u>();
</big></dt>
<dd>Duplicates the  and its contents.<br><br>

</dd>
<dt><big><a name="BitSet.opApply"></a>int <u>opApply</u>(scope int delegate(ref bool) <i>dg</i>);
<br>const int <u>opApply</u>(scope int delegate(bool) <i>dg</i>);
<br>int <u>opApply</u>(scope int delegate(ref size_t, ref bool) <i>dg</i>);
<br>const int <u>opApply</u>(scope int delegate(size_t, bool) <i>dg</i>);
</big></dt>
<dd>Support for  loops for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opApply unittest\n"</font>);
<font color=blue>static</font> <font color=blue>bool</font>[] ba = [1,0,1];
<font color=blue>auto</font> a = BitSet!3(ba);
size_t i;
<font color=blue>foreach</font> (b; a)
{
    <font color=blue>switch</font> (i)
    {
    <font color=blue>case</font> 0: <font color=blue>assert</font>(b == <font color=blue>true</font>); <font color=blue>break</font>;
    <font color=blue>case</font> 1: <font color=blue>assert</font>(b == <font color=blue>false</font>); <font color=blue>break</font>;
    <font color=blue>case</font> 2: <font color=blue>assert</font>(b == <font color=blue>true</font>); <font color=blue>break</font>;
    <font color=blue>default</font>: <font color=blue>assert</font>(0);
    }
    i++;
}
<font color=blue>foreach</font> (j, b; a)
{
    <font color=blue>switch</font> (j)
    {
    <font color=blue>case</font> 0: <font color=blue>assert</font>(b == <font color=blue>true</font>); <font color=blue>break</font>;
    <font color=blue>case</font> 1: <font color=blue>assert</font>(b == <font color=blue>false</font>); <font color=blue>break</font>;
    <font color=blue>case</font> 2: <font color=blue>assert</font>(b == <font color=blue>true</font>); <font color=blue>break</font>;
    <font color=blue>default</font>: <font color=blue>assert</font>(0);
    }
}
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.reverse"></a>@property BitSet <u>reverse</u>();
</big></dt>
<dd>Reverses the bits of the  in place.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> len = 64;
<font color=blue>static</font> <font color=blue>bool</font>[len] data = [0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0];
<font color=blue>auto</font> b = BitSet!len(data);
b.<u>reverse</u>;
<font color=blue>for</font> (size_t i = 0; i &lt; data.length; ++i)
{
    <font color=blue>assert</font>(b[i] == data[len - 1 - i]);
}
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> len = 64*2;
<font color=blue>static</font> <font color=blue>bool</font>[len] data = [0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0];
<font color=blue>auto</font> b = BitSet!len(data);
b.<u>reverse</u>;
<font color=blue>for</font> (size_t i = 0; i &lt; data.length; ++i)
{
    <font color=blue>assert</font>(b[i] == data[len - 1 - i]);
}
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> len = 64*3;
<font color=blue>static</font> <font color=blue>bool</font>[len] data = [0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0,
                         0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0, 0,1,1,0,1,0,1,0];
<font color=blue>auto</font> b = BitSet!len(data);
b.<u>reverse</u>;
<font color=blue>for</font> (size_t i = 0; i &lt; data.length; ++i)
{
    <font color=blue>assert</font>(b[i] == data[len - 1 - i]);
}
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.sort"></a>@property BitSet <u>sort</u>();
</big></dt>
<dd>Sorts the 's elements.<br><br>

</dd>
<dt><big><a name="BitSet.opEquals"></a>const bool <u>opEquals</u>(Block2)(in BitSet!(len, Block2) <i>a2</i>) if (isUnsigned!Block2);
</big></dt>
<dd>Support for operators == and != for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opEquals unittest\n"</font>);
<font color=blue>auto</font> a = BitSet!(5, <font color=blue>ubyte</font>)([1,0,1,0,1]);
<font color=blue>auto</font> b = BitSet!(5, <font color=blue>ushort</font>)([1,0,1,1,1]);
<font color=blue>auto</font> c = BitSet!(5, <font color=blue>uint</font>)([1,0,1,0,1]);
<font color=blue>auto</font> d = BitSet!(5, <font color=blue>ulong</font>)([1,1,1,1,1]);
<font color=blue>assert</font>(a != b);
<font color=blue>assert</font>(a == c);
<font color=blue>assert</font>(a != d);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opCmp"></a>const int <u>opCmp</u>(Block2)(in BitSet!(len, Block2) <i>a2</i>) if (isUnsigned!Block2);
</big></dt>
<dd>Supports comparison operators for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opCmp unittest\n"</font>);
<font color=blue>auto</font> a = BitSet!(5, <font color=blue>ubyte</font>)([1,0,1,0,1]);
<font color=blue>auto</font> b = BitSet!(5, <font color=blue>ushort</font>)([1,0,1,1,1]);
<font color=blue>auto</font> c = BitSet!(5, <font color=blue>uint</font>)([1,0,1,0,1]);
<font color=blue>auto</font> d = BitSet!(5, <font color=blue>ulong</font>)([1,1,1,1,1]);
<font color=blue>assert</font>(a &lt;  b);
<font color=blue>assert</font>(a &lt;= b);
<font color=blue>assert</font>(a == c);
<font color=blue>assert</font>(a &lt;= c);
<font color=blue>assert</font>(a &gt;= c);
<font color=blue>assert</font>(c &lt; d);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.toHash"></a>const pure nothrow @trusted size_t <u>toHash</u>();
</big></dt>
<dd>Support for hashing for .<br><br>

</dd>
<dt><big><a name="BitSet.this"></a>this(bool[] <i>ba</i>);
</big></dt>
<dd>Set this  to the contents of .<br><br>

</dd>
<dt><big><a name="BitSet.this.2"></a>this(ref const bool[len] <i>ba</i>);
</big></dt>
<dd>Set this  to the contents of .<br><br>

</dd>
<dt><big><a name="BitSet.allZero"></a>const pure nothrow @nogc @safe bool <u>allZero</u>();
</big></dt>
<dd>Check if this  has only zeros (is empty).<br><br>

</dd>
<dt><big><a name="BitSet.allOneBetween"></a>const pure nothrow @nogc @safe bool <u>allOneBetween</u>(size_t <i>low</i>, size_t <i>high</i>);
</big></dt>
<dd>Check if this  has only ones in range [ ,  [.<br><br>

</dd>
<dt><big><a name="BitSet.OneIndexes"></a>struct <u>OneIndexes</u>;
</big></dt>
<dd>Range over all indexes hold a one (set bit).<br><br>

</dd>
<dt><big><a name="BitSet.oneIndexes"></a>const pure nothrow @safe auto <u>oneIndexes</u>();
</big></dt>
<dd>Get indexes of all bits set.<br><br>

</dd>
<dt><big><a name="BitSet.countOnes"></a>const pure nothrow @nogc @safe Mod!(len + 1) <u>countOnes</u>();
</big></dt>
<dd>Get number of bits set in .<br><br>

</dd>
<dt><big><a name="BitSet.denseness"></a>const pure nothrow @nogc @safe Q <u>denseness</u>(int <i>depth</i> = -1);
</big></dt>
<dd>Get number of bits set in .<br><br>

</dd>
<dt><big><a name="BitSet.sparseness"></a>const pure nothrow @nogc @safe Q <u>sparseness</u>(int <i>depth</i> = -1);
</big></dt>
<dd>Get number of Bits Unset in .<br><br>

</dd>
<dt><big><a name="BitSet.allOne"></a>const pure nothrow @safe bool <u>allOne</u>();
</big></dt>
<dd>Check if this  has only ones (is full).<br><br>

</dd>
<dt><big><a name="BitSet.canFindIndexOf"></a>const pure nothrow @nogc @safe bool <u>canFindIndexOf</u>(ModUInt)(bool <i>value</i>, Mod!(len, ModUInt) <i>currIx</i>, out Mod!(len, ModUInt) <i>nextIx</i>) if (isUnsigned!ModUInt);
</big></dt>
<dd>Find index (starting at <pre style="display:inline;" class="d_inline_code"><i>currIx</i></pre>) of first bit that equals <pre style="display:inline;" class="d_inline_code"><i>value</i></pre>.
<br><br>
<b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if index was found (hit index is put into <pre style="display:inline;" class="d_inline_code"><i>nextIx</i></pre>), <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.
            TODO block-optimize for large BitSets<br><br>

</dd>
<dt><big><a name="BitSet.opCast"></a>void[] <u>opCast</u>(T : void[])();
</big></dt>
<dd>Map the  onto , with  being the number of bits
 in the array. Does not copy the data.
<br><br>
This is the inverse of .
<br><br>

 Convert to .<br><br>

</dd>
<dt><big><a name="BitSet.opCast.2"></a>size_t[] <u>opCast</u>(T : size_t[])();
</big></dt>
<dd>Convert to .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opCast unittest\n"</font>);
<font color=blue>static</font> <font color=blue>bool</font>[] ba = [1,0,1,0,1];
<font color=blue>auto</font> a = BitSet!5(ba);
<font color=blue>void</font>[] v = <font color=blue>cast</font>(<font color=blue>void</font>[])a;
<font color=blue>assert</font>(v.length == a.dim * size_t.sizeof);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opCom"></a>const BitSet <u>opCom</u>();
</big></dt>
<dd>Support for unary operator ~ for .<br><br>

</dd>
<dt><big><a name="BitSet.opAnd"></a>const BitSet <u>opAnd</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for binary operator &amp; for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opAnd unittest\n"</font>);
<font color=blue>const</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>auto</font> b = BitSet!5([1,0,1,1,0]);
<font color=blue>const</font> c = a &amp; b;
<font color=blue>auto</font> d = BitSet!5([1,0,1,0,0]);
<font color=blue>assert</font>(c == d);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opOr"></a>const BitSet <u>opOr</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for binary operator | for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opOr unittest\n"</font>);
<font color=blue>const</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>auto</font> b = BitSet!5([1,0,1,1,0]);
<font color=blue>const</font> c = a | b;
<font color=blue>auto</font> d = BitSet!5([1,0,1,1,1]);
<font color=blue>assert</font>(c == d);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opXor"></a>const BitSet <u>opXor</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for binary operator ^ for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opXor unittest\n"</font>);
<font color=blue>const</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>auto</font> b = BitSet!5([1,0,1,1,0]);
<font color=blue>const</font> c = a ^ b;
<font color=blue>auto</font> d = BitSet!5([0,0,0,1,1]);
<font color=blue>assert</font>(c == d);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opSub"></a>const BitSet <u>opSub</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for binary operator - for .
<br><br>
 for  means the same thing as .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opSub unittest\n"</font>);
<font color=blue>const</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>auto</font> b = BitSet!5([1,0,1,1,0]);
<font color=blue>const</font> c = a - b;
<font color=blue>auto</font> d = BitSet!5([0,0,0,0,1]);
<font color=blue>assert</font>(c == d);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opAndAssign"></a>BitSet <u>opAndAssign</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for operator &amp;= for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opAndAssign unittest\n"</font>);
<font color=blue>auto</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>const</font> b = BitSet!5([1,0,1,1,0]);
a &amp;= b;
<font color=blue>const</font> c = BitSet!5([1,0,1,0,0]);
<font color=blue>assert</font>(a == c);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opOrAssign"></a>BitSet <u>opOrAssign</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for operator |= for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opOrAssign unittest\n"</font>);
<font color=blue>auto</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>const</font> b = BitSet!5([1,0,1,1,0]);
a |= b;
<font color=blue>const</font> c = BitSet!5([1,0,1,1,1]);
<font color=blue>assert</font>(a == c);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opXorAssign"></a>BitSet <u>opXorAssign</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for operator ^= for .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opXorAssign unittest\n"</font>);
<font color=blue>auto</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>const</font> b = BitSet!5([1,0,1,1,0]);
a ^= b;
<font color=blue>const</font> c = BitSet!5([0,0,0,1,1]);
<font color=blue>assert</font>(a == c);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.opSubAssign"></a>BitSet <u>opSubAssign</u>(in BitSet <i>e2</i>);
</big></dt>
<dd>Support for operator -= for .
<br><br>
 for  means the same thing as .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>debug</font>(bitset) printf(<font color=red>"BitSet.opSubAssign unittest\n"</font>);
<font color=blue>auto</font> a = BitSet!5([1,0,1,0,1]);
<font color=blue>const</font> b = BitSet!5([1,0,1,1,0]);
a -= b;
<font color=blue>const</font> c = BitSet!5([0,0,0,0,1]);
<font color=blue>assert</font>(a == c);
</pre>
<br><br>
</dd>
<dt><big><a name="BitSet.toString"></a>const void <u>toString</u>(scope void delegate(const(char)[]) <i>sink</i>, FormatSpec!char <i>fmt</i>);
</big></dt>
<dd>Return a string representation of this BitSet.
<br><br>
Two format specifiers are supported:
 <li><b>%s</b> which prints the bits as an array, and</li>
 <li><b>%b</b> which prints the bits as 8-bit byte packets</li>
 separated with an underscore.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>const</font> b = BitSet!16(([0, 0, 0, 0, 1, 1, 1, 1,
                     0, 0, 0, 0, 1, 1, 1, 1]));
<font color=blue>const</font> s1 = format(<font color=red>"%s"</font>, b);
<font color=blue>assert</font>(s1 == <font color=red>"[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]"</font>);

<font color=blue>const</font> s2 = format(<font color=red>"%b"</font>, b);
<font color=blue>assert</font>(s2 == <font color=red>"00001111_00001111"</font>);
</pre>
<br><br>
</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Per Nordlöw 2014-.
</small>
        </body></html>
