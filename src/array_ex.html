<html><head>
        <!-- Generated by Ddoc from array_ex.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>array_ex</title>
        </head><body>
        <h1>array_ex</h1>
Array container(s) with optional sortedness via template-parameter
    <pre style="display:inline;" class="d_inline_code">Ordering</pre> and optional use of GC via <pre style="display:inline;" class="d_inline_code">useGCAllocation</pre>.
<br><br>
TODO Breakout common logic into <pre style="display:inline;" class="d_inline_code">RawArray</pre> and reuse with <pre style="display:inline;" class="d_inline_code">alias this</pre>
<br><br>

    TODO Remove explicit moves when DMD std.algorithm.mutation.move calls these
    members for us (if they exist)
<br><br>

    TODO Allow y = sort(x.move()), where x and y are instances of unsorted Array
<br><br>

    TODO Use std.array.insertInPlace in insert()?
    TODO Use std.array.replaceInPlace?
<br><br>

    TODO Split up <pre style="display:inline;" class="d_inline_code">Array</pre> into <pre style="display:inline;" class="d_inline_code">Array</pre>, <pre style="display:inline;" class="d_inline_code">SortedArray</pre>, <pre style="display:inline;" class="d_inline_code">SetArray</pre> and reuse
    logic in <pre style="display:inline;" class="d_inline_code">Array</pre> via <pre style="display:inline;" class="d_inline_code">alias this</pre> or free functions.
<br><br>

    TODO Use <pre style="display:inline;" class="d_inline_code">std.algorithm.mutation.move</pre> and <pre style="display:inline;" class="d_inline_code">std.range.primitives.moveAt</pre>
    when moving internal sub-slices
<br><br>

    TODO struct Store, Notify andralex of packed array
<br><br>

    TODO Add <pre style="display:inline;" class="d_inline_code">c.insertAfter(r, x)</pre> where <pre style="display:inline;" class="d_inline_code">c</pre> is a collection, <pre style="display:inline;" class="d_inline_code">r</pre> is a range
    previously extracted from <pre style="display:inline;" class="d_inline_code">c</pre>, and <pre style="display:inline;" class="d_inline_code">x</pre> is a value convertible to
    collection's element type. See also:
<br><br>
<b>https:</b><br>
//forum.dlang.org/post/n3qq6ebis@digitalmars.com
<br><br>

    TODO All Array with const members and movals
<br><br>

    TODO replace qcmeman with std.experimental.allocator parameter defaulting to
    <pre style="display:inline;" class="d_inline_code">Mallocator</pre><br><br>

<dl><dt><big><a name="asStatic"></a>auto <u>asStatic</u>(T, size_t length)(T[length] <i>arr</i>);
</big></dt>
<dd><b>Returns:</b><br>
statically (stack) allocated array with elements of type <pre style="display:inline;" class="d_inline_code">T</pre> of
    length <pre style="display:inline;" class="d_inline_code">n</pre>.
<br><br>

    For more convenient usage alias it as `s' together with UFCS for the
    following convenient notation:
<br><br>

    auto x = [1, 2, 3].s;
<br><br>

    TODO Useful alternative names are <pre style="display:inline;" class="d_inline_code">a{as,to}{Static,Fixed}</pre>, <pre style="display:inline;" class="d_inline_code">fix</pre>, <pre style="display:inline;" class="d_inline_code">fixed</pre> , <pre style="display:inline;" class="d_inline_code">statically</pre>, <pre style="display:inline;" class="d_inline_code">onStack</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [1, 2, 3].<u>asStatic</u>;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(x) == <font color=blue>int</font>[x.length]));
</pre>
<br><br>
</dd>
<dt><big><a name="isMyArray"></a>enum auto <u>isMyArray</u>(C);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff <pre style="display:inline;" class="d_inline_code">C</pre> is an <pre style="display:inline;" class="d_inline_code">Array</pre>.<br><br>

</dd>
<dt><big><a name="Assignment"></a>enum <u>Assignment</u>: int;
</big></dt>
<dd>Semantics of copy construction and assignment.<br><br>

<dl><dt><big><a name="Assignment.disabled"></a><u>disabled</u></big></dt>
<dd>for reference counting use <pre style="display:inline;" class="d_inline_code">std.typecons.RefCounted</pre><br><br>

</dd>
<dt><big><a name="Assignment.move"></a><u>move</u></big></dt>
<dd>only <u>move</u> construction allowed<br><br>

</dd>
<dt><big><a name="Assignment.copy"></a><u>copy</u></big></dt>
<dd>always <u>copy</u> (often not the desirable)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Array"></a>struct <u>Array</u>(E, Assignment assignment = Assignment.disabled, Ordering ordering = Ordering.unsorted, bool useGCAllocation = false, alias less = "a &lt; b");
</big></dt>
<dd><u>Array</u> of value types <pre style="display:inline;" class="d_inline_code">E</pre> with optional sortedness/ordering.
<br><br>
    Always <pre style="display:inline;" class="d_inline_code">@safe pure nothrow @nogc</pre> when possible.
<br><br>

    <pre style="display:inline;" class="d_inline_code">Assignment</pre> either
    - is disabled
    - does Rust-style move, or
    - does C++-style copying

<br><br>
<b>Params:</b><br>
<table><tr><td>useGCAllocation</td>
<td><pre style="display:inline;" class="d_inline_code">true</pre> iff <pre style="display:inline;" class="d_inline_code">GC.malloc</pre> is used for store allocation,
                          otherwise C's <pre style="display:inline;" class="d_inline_code">{m,ce,re}alloc()</pre> is used.</td></tr>
</table><br>

<dl><dt><big><a name="Array.isString"></a>enum auto <u>isString</u>;
</big></dt>
<dd>Type of element stored.
<br><br>
Is <pre style="display:inline;" class="d_inline_code">true</pre> iff <pre style="display:inline;" class="d_inline_code">Array</pre> can be interpreted as a D <pre style="display:inline;" class="d_inline_code">string</pre>, <pre style="display:inline;" class="d_inline_code">wstring</pre> or <pre style="display:inline;" class="d_inline_code">dstring</pre>.<br><br>

</dd>
<dt><big><a name="Array.smallLength"></a>enum auto <u>smallLength</u>;
</big></dt>
<dd>Maximum number of elements that fits in SSO-packed<br><br>

</dd>
<dt><big><a name="Array.isSmall"></a>const pure nothrow @nogc @safe bool <u>isSmall</u>();
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff is SSO-packed.<br><br>

</dd>
<dt><big><a name="Array.this"></a>nothrow this(typeof(null));
</big></dt>
<dd>Create a empty array.<br><br>

</dd>
<dt><big><a name="Array.withLength"></a>static nothrow @trusted typeof(this) <u>withLength</u>(size_t <i>initialLength</i>);
</big></dt>
<dd><b>Returns:</b><br>
an array of length <pre style="display:inline;" class="d_inline_code"><i>initialLength</i></pre> with all elements default-initialized to <pre style="display:inline;" class="d_inline_code">ElementType.init</pre>.<br><br>

</dd>
<dt><big><a name="Array.withCapacity"></a>static nothrow @trusted typeof(this) <u>withCapacity</u>(size_t <i>initialCapacity</i>);
</big></dt>
<dd><b>Returns:</b><br>
an array with initial capacity <pre style="display:inline;" class="d_inline_code"><i>initialCapacity</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.withElement"></a>static nothrow @trusted typeof(this) <u>withElement</u>(E <i>element</i>);
</big></dt>
<dd><b>Returns:</b><br>
an array of length 1 with first <i>element</i> set to <pre style="display:inline;" class="d_inline_code"><i>element</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.opAssign"></a>@trusted void <u>opAssign</u>(typeof(this) <i>rhs</i>);
</big></dt>
<dd>Copy assignment.<br><br>

</dd>
<dt><big><a name="Array.opEquals"></a>const bool <u>opEquals</u>(R)(R <i>rhs</i>);
</big></dt>
<dd>Compare with range <pre style="display:inline;" class="d_inline_code">R</pre> with comparable element type.<br><br>

</dd>
<dt><big><a name="Array.toHash"></a>const pure nothrow @trusted size_t <u>toHash</u>();
</big></dt>
<dd>Calculate AA hash.<br><br>

</dd>
<dt><big><a name="Array.this.2"></a>@trusted this(R)(R <i>values</i>, bool <i>assumeSortedParameter</i> = false) if (isInputRange!R);
</big></dt>
<dd>Construct from InputRange <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>.
        If <pre style="display:inline;" class="d_inline_code"><i>values</i></pre> are sorted <pre style="display:inline;" class="d_inline_code"><i>assumeSortedParameter</i></pre> is <pre style="display:inline;" class="d_inline_code">true</pre>.<br><br>

</dd>
<dt><big><a name="Array.reserve"></a>pure nothrow @trusted void <u>reserve</u>(size_t <i>newCapacity</i>);
</big></dt>
<dd>Reserve room for <pre style="display:inline;" class="d_inline_code"><i>newCapacity</i></pre> elements at store <pre style="display:inline;" class="d_inline_code">_ptr</pre>.<br><br>

</dd>
<dt><big><a name="Array.compress"></a>pure nothrow @trusted void <u>compress</u>();
</big></dt>
<dd>Pack/Compress storage.<br><br>

</dd>
<dt><big><a name="Array.clear"></a>void <u>clear</u>();
</big></dt>
<dd>Destruct.<br><br>

</dd>
<dt><big><a name="Array.linearPopAtIndex"></a>@trusted ContainerElementType!(typeof(this), E) <u>linearPopAtIndex</u>(size_t <i>index</i>);
</big></dt>
<dd>Removal doesn't need to care about ordering.<br><br>

</dd>
<dt><big><a name="Array.linearPopFront"></a>@trusted ContainerElementType!(typeof(this), E) <u>linearPopFront</u>();
</big></dt>
<dd>Removal doesn't need to care about ordering.<br><br>

</dd>
<dt><big><a name="Array.popBack"></a>@safe void <u>popBack</u>();
</big></dt>
<dd>Removal doesn't need to care about ordering.<br><br>

</dd>
<dt><big><a name="Array.backPop"></a>@trusted E <u>backPop</u>();
</big></dt>
<dd>Pop back element and return it.<br><br>

</dd>
<dt><big><a name="Array.popBackN"></a>@safe void <u>popBackN</u>(size_t <i>count</i>);
</big></dt>
<dd>Pop last <pre style="display:inline;" class="d_inline_code"><i>count</i></pre> back elements.<br><br>

</dd>
<dt><big><a name="Array.pushBack"></a>@trusted void <u>pushBack</u>(Us...)(Us <i>values</i>) if (<i>values</i>.length &gt;= 1 &amp;&amp; allSatisfy!(isElementAssignable, Us));
<br>void <u>pushBack</u>(R)(R <i>values</i>) if (isInputRange!R &amp;&amp; !isArray!R &amp;&amp; !isMyArray!R &amp;&amp; isElementAssignable!(ElementType!R));
</big></dt>
<dd>Push back (append) <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.pushBack.2"></a>@trusted void <u>pushBack</u>(A)(A <i>values</i>) if (isArray!A &amp;&amp; isElementAssignable!(ElementType!A));
</big></dt>
<dd>ditto.<br><br>

</dd>
<dt><big><a name="Array.pushBack.3"></a>@trusted void <u>pushBack</u>(A)(ref const A <i>values</i>) if (isMyArray!A &amp;&amp; isElementAssignable!(ElementType!A));
</big></dt>
<dd>ditto.<br><br>

</dd>
<dt><big><a name="Array.contains"></a>const nothrow @nogc bool <u>contains</u>(U)(U <i>value</i>);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff this <u>contains</u> <pre style="display:inline;" class="d_inline_code"><i>value</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.lowerBound"></a>inout auto <u>lowerBound</u>(SearchPolicy sp = SearchPolicy.binarySearch, U)(U <i>e</i>);
</big></dt>
<dd>Wrapper for <pre style="display:inline;" class="d_inline_code">std.range.SortedRange.<u>lowerBound</u></pre> when this <pre style="display:inline;" class="d_inline_code">ordering</pre> is sorted.<br><br>

</dd>
<dt><big><a name="Array.upperBound"></a>inout auto <u>upperBound</u>(SearchPolicy sp = SearchPolicy.binarySearch, U)(U <i>e</i>);
</big></dt>
<dd>Wrapper for <pre style="display:inline;" class="d_inline_code">std.range.SortedRange.<u>upperBound</u></pre> when this <pre style="display:inline;" class="d_inline_code">ordering</pre> is sorted.<br><br>

</dd>
<dt><big><a name="Array.linearInsert"></a>bool[Us.length] <u>linearInsert</u>(SearchPolicy sp = SearchPolicy.binarySearch, Us...)(Us <i>values</i>) if (<i>values</i>.length &gt;= 1 &amp;&amp; allSatisfy!(isElementAssignable, Us));
</big></dt>
<dd>Inserts <pre style="display:inline;" class="d_inline_code"><i>values</i></pre> into <pre style="display:inline;" class="d_inline_code">this</pre> ordered set.
<br><br>
<b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">bool</pre>-array with same length as <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>, where i:th
                <pre style="display:inline;" class="d_inline_code">bool</pre> value is set if <pre style="display:inline;" class="d_inline_code">value[i]</pre> wasn't previously in <pre style="display:inline;" class="d_inline_code">this</pre>.<br><br>

</dd>
<dt><big><a name="Array.opSlice"></a>auto <u>opSlice</u>();
<br>auto <u>opSlice</u>(this This)(size_t <i>i</i>, size_t <i>j</i>);
</big></dt>
<dd>Slice operator must be const when ordered.
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Array.opIndex"></a>ref const(E) <u>opIndex</u>(size_t <i>i</i>);
</big></dt>
<dd>Index operator must be const to preserve ordering.
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Array.front"></a>ref const(E) <u>front</u>();
</big></dt>
<dd>Get <u>front</u> element (as constant reference to preserve ordering).
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Array.back"></a>ref const(E) <u>back</u>();
</big></dt>
<dd>Get <u>back</u> element (as constant reference to preserve ordering).
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Array.empty"></a>const @safe bool <u>empty</u>();
</big></dt>
<dd>Check if <u>empty</u>.<br><br>

</dd>
<dt><big><a name="Array.length"></a>const @safe size_t <u>length</u>();
<br><a name="Array.opDollar"></a>alias <u>opDollar</u> = length;
</big></dt>
<dd>Get <u>length</u>.<br><br>

</dd>
<dt><big><a name="Array.reservedLength"></a>const @safe size_t <u>reservedLength</u>();
</big></dt>
<dd>Get length of reserved store.<br><br>

</dd>
<dt><big><a name="Array.shrinkTo"></a>@safe void <u>shrinkTo</u>(size_t <i>newLength</i>);
</big></dt>
<dd>Shrink length to <pre style="display:inline;" class="d_inline_code"><i>newLength</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.ptr"></a>inout inout(E*) <u>ptr</u>();
</big></dt>
<dd>Get internal pointer.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
