<html><head>
        <!-- Generated by Ddoc from /home/per/Work/justd/phobos-next/src/array_ex.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>array_ex</title>
        </head><body>
        <h1>array_ex</h1>
Array container(s) with optional sortedness via template-parameter
    <pre style="display:inline;" class="d_inline_code">Ordering</pre> and optional use of GC via <pre style="display:inline;" class="d_inline_code">useGCAllocation</pre>.
<br><br>
BUG rdmd -main -unittest -g -debug <u>array_ex</u>
    dustmite --strip-comments --no-redirect src "show-segfault rdmd -main -unittest -g -debug <u>array_ex</u> | grep double-linked"
<br><br>

    TODO Breakout common logic into <pre style="display:inline;" class="d_inline_code">RawArray</pre> and reuse with <pre style="display:inline;" class="d_inline_code">alias this</pre>
<br><br>

    TODO Remove explicit moves when DMD std.algorithm.mutation.move calls these
    members for us (if they exist)
<br><br>

    TODO Allow y = sort(x.move()), where x and y are instances of unsorted Array
<br><br>

    TODO Use std.array.insertInPlace in insert()?
    TODO Use std.array.replaceInPlace?
<br><br>

    TODO Split up <pre style="display:inline;" class="d_inline_code">Array</pre> into <pre style="display:inline;" class="d_inline_code">Array</pre>, <pre style="display:inline;" class="d_inline_code">SortedArray</pre>, <pre style="display:inline;" class="d_inline_code">SetArray</pre> and reuse
    logic in <pre style="display:inline;" class="d_inline_code">Array</pre> via <pre style="display:inline;" class="d_inline_code">alias this</pre> or free functions.
<br><br>

    TODO Use <pre style="display:inline;" class="d_inline_code">std.algorithm.mutation.move</pre> and <pre style="display:inline;" class="d_inline_code">std.range.primitives.moveAt</pre>
    when moving internal sub-slices
<br><br>

    TODO struct Store, Notify andralex of packed array
<br><br>

    TODO Add <pre style="display:inline;" class="d_inline_code">c.insertAfter(r, x)</pre> where <pre style="display:inline;" class="d_inline_code">c</pre> is a collection, <pre style="display:inline;" class="d_inline_code">r</pre> is a range
    previously extracted from <pre style="display:inline;" class="d_inline_code">c</pre>, and <pre style="display:inline;" class="d_inline_code">x</pre> is a value convertible to
    collection's element type. See also:
<br><br>
<b>https:</b><br>
//forum.dlang.org/post/n3qq6ebis@digitalmars.com
<br><br>

    TODO All Array with const members and movals
<br><br>

    TODO replace qcmeman with std.experimental.allocator parameter defaulting to
    <pre style="display:inline;" class="d_inline_code">Mallocator</pre><br><br>

<dl><dt><big><a name="asStatic"></a>auto <u>asStatic</u>(T, size_t length)(T[length] <i>arr</i>);
</big></dt>
<dd><b>Returns:</b><br>
statically (stack) allocated array with elements of type <pre style="display:inline;" class="d_inline_code">T</pre> of
    length <pre style="display:inline;" class="d_inline_code">n</pre>.
<br><br>

    For more convenient usage alias it as `s' together with UFCS for the
    following convenient notation:
<br><br>

    auto x = [1, 2, 3].s;
<br><br>

    TODO Useful alternative names are <pre style="display:inline;" class="d_inline_code">a{as,to}{Static,Fixed}</pre>, <pre style="display:inline;" class="d_inline_code">fix</pre>, <pre style="display:inline;" class="d_inline_code">fixed</pre> , <pre style="display:inline;" class="d_inline_code">statically</pre>, <pre style="display:inline;" class="d_inline_code">onStack</pre>.
<br><br>

    TODO Add to Phobos <pre style="display:inline;" class="d_inline_code">std.array</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [1, 2, 3].<u>asStatic</u>;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(x) == <font color=blue>int</font>[x.length]));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>([1, 2, 3].<u>asStatic</u>) == <font color=blue>int</font>[x.length]));
</pre>
<br><br>
</dd>
<dt><big><a name="isMyArray"></a>enum auto <u>isMyArray</u>(C);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff <pre style="display:inline;" class="d_inline_code">C</pre> is an <pre style="display:inline;" class="d_inline_code">Array</pre>.<br><br>

</dd>
<dt><big><a name="isCopyable"></a>enum auto <u>isCopyable</u>(T);
</big></dt>
<dd>Is <pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code">T</pre> is assignable.<br><br>

</dd>
<dt><big><a name="Assignment"></a>enum <u>Assignment</u>: int;
</big></dt>
<dd>Semantics of copy construction and assignment.<br><br>

<dl><dt><big><a name="Assignment.disabled"></a><u>disabled</u></big></dt>
<dd>for reference counting use <pre style="display:inline;" class="d_inline_code">std.typecons.RefCounted</pre><br><br>

</dd>
<dt><big><a name="Assignment.move"></a><u>move</u></big></dt>
<dd>only <u>move</u> construction allowed<br><br>

</dd>
<dt><big><a name="Assignment.copy"></a><u>copy</u></big></dt>
<dd>always <u>copy</u> (often not the desirable)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="withCapacityMake"></a>R <u>withCapacityMake</u>(R)(size_t <i>capacity</i>) if (hasMember!(R, "withCapacity"));
<br>R <u>withCapacityMake</u>(R)(size_t <i>capacity</i>) if (isDynamicArray!R);
</big></dt>
<dd>Return an instance of <pre style="display:inline;" class="d_inline_code">R</pre> with <i>capacity</i> <pre style="display:inline;" class="d_inline_code"><i>capacity</i></pre>.<br><br>

</dd>
<dt><big><a name="withLengthMake"></a>R <u>withLengthMake</u>(R)(size_t <i>length</i>) if (hasMember!(R, "withLength"));
<br>R <u>withLengthMake</u>(R)(size_t <i>length</i>) if (isDynamicArray!R);
</big></dt>
<dd>Return an instance of <pre style="display:inline;" class="d_inline_code">R</pre> of <i>length</i> <pre style="display:inline;" class="d_inline_code"><i>length</i></pre>.<br><br>

</dd>
<dt><big><a name="withElementMake"></a>R <u>withElementMake</u>(R)(typeof(R.init[0]) <i>e</i>) if (hasMember!(R, "withElement"));
<br>R <u>withElementMake</u>(R)(typeof(R.init[0]) <i>e</i>) if (isDynamicArray!R);
</big></dt>
<dd>Return an instance of <pre style="display:inline;" class="d_inline_code">R</pre> containing a single element <pre style="display:inline;" class="d_inline_code"><i>e</i></pre>.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
