<html><head>
        <!-- Generated by Ddoc from /home/per/Work/justd/phobos-next/src/array_ex.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>array_ex</title>
        </head><body>
        <h1>array_ex</h1>
Array container(s) with optional sortedness via template-parameter
    <pre style="display:inline;" class="d_inline_code">Ordering</pre> and optional use of GC via <pre style="display:inline;" class="d_inline_code">useGCAllocation</pre>.
<br><br>
TODO Make Array have reference assignment instead through via Automatic
    Reference Counting and scope keyword when DIP-1000 has been implemented
<br><br>

    TODO Use std.array.insertInPlace in insert()?
    TODO Use std.array.replaceInPlace?
<br><br>

    TODO Split up <pre style="display:inline;" class="d_inline_code">Array</pre> into <pre style="display:inline;" class="d_inline_code">Array</pre>, <pre style="display:inline;" class="d_inline_code">SortedArray</pre>, <pre style="display:inline;" class="d_inline_code">SetArray</pre> and reuse
    logic in <pre style="display:inline;" class="d_inline_code">Array</pre> via <pre style="display:inline;" class="d_inline_code">alias this</pre> or free functions.
<br><br>

    TODO Use <pre style="display:inline;" class="d_inline_code">std.algorithm.mutation.move</pre> and <pre style="display:inline;" class="d_inline_code">std.range.primitives.moveAt</pre>
    when moving internal sub-slices
<br><br>

    TODO struct Store, Notify andralex of packed array
<br><br>

    TODO Add <pre style="display:inline;" class="d_inline_code">c.insertAfter(r, x)</pre> where <pre style="display:inline;" class="d_inline_code">c</pre> is a collection, <pre style="display:inline;" class="d_inline_code">r</pre> is a range
    previously extracted from <pre style="display:inline;" class="d_inline_code">c</pre>, and <pre style="display:inline;" class="d_inline_code">x</pre> is a value convertible to
    collection's element type. See also:
<br><br>
<b>https:</b><br>
//forum.dlang.org/post/n3qq6ebis@digitalmars.com<br><br>

<dl><dt><big><a name="shouldAddGCRange"></a>enum auto <u>shouldAddGCRange</u>(T);
</big></dt>
<dd>Is <pre style="display:inline;" class="d_inline_code">true</pre> iff <pre style="display:inline;" class="d_inline_code">T</pre> is a type whose instances need to be scanned by the garbage
    collector (GC).<br><br>

</dd>
<dt><big><a name="Assignment"></a>enum <u>Assignment</u>: int;
</big></dt>
<dd>Semantics of copy construction and assignment.<br><br>

<dl><dt><big><a name="Assignment.disabled"></a><u>disabled</u></big></dt>
<dd>for reference counting use <pre style="display:inline;" class="d_inline_code">std.typecons.RefCounted</pre><br><br>

</dd>
<dt><big><a name="Assignment.move"></a><u>move</u></big></dt>
<dd>only <u>move</u> construction allowed<br><br>

</dd>
<dt><big><a name="Assignment.copy"></a><u>copy</u></big></dt>
<dd>always <u>copy</u> (often not the desirable)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Array"></a>struct <u>Array</u>(E, Assignment assignment = Assignment.disabled, Ordering ordering = Ordering.unsorted, bool useGCAllocation = false, alias less = "a &lt; b");
</big></dt>
<dd><u>Array</u> of value types <pre style="display:inline;" class="d_inline_code">E</pre> with optional ordering given by <pre style="display:inline;" class="d_inline_code">ordering</pre>.
<br><br>
Copy construction and assignment currently does copying.
<br><br>

    For move construction use <pre style="display:inline;" class="d_inline_code">std.algorithm.mutation.move(source, target)</pre>
    where both arguments are instances of <pre style="display:inline;" class="d_inline_code"><u>Array</u></pre>.<br><br>

<dl><dt><big><a name="Array.isString"></a>enum auto <u>isString</u>;
</big></dt>
<dd>Is <pre style="display:inline;" class="d_inline_code">true</pre> iff array can be interpreted as a D <pre style="display:inline;" class="d_inline_code">string</pre>, <pre style="display:inline;" class="d_inline_code">wstring</pre> or <pre style="display:inline;" class="d_inline_code">dstring</pre>.<br><br>

</dd>
<dt><big><a name="Array.smallLength"></a>enum auto <u>smallLength</u>;
</big></dt>
<dd>Maximum number of elements that fits in SSO-packed<br><br>

</dd>
<dt><big><a name="Array.isSmall"></a>const pure nothrow @nogc @safe bool <u>isSmall</u>();
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff is SSO-packed.<br><br>

</dd>
<dt><big><a name="Array.this"></a>nothrow this(typeof(null));
</big></dt>
<dd>Create a empty array.<br><br>

</dd>
<dt><big><a name="Array.withLength"></a>static nothrow typeof(this) <u>withLength</u>(size_t <i>n</i>);
</big></dt>
<dd><b>Returns:</b><br>
an array of length <pre style="display:inline;" class="d_inline_code"><i>n</i></pre> with all elements default-initialized.<br><br>

</dd>
<dt><big><a name="Array.withElement"></a>static nothrow typeof(this) <u>withElement</u>(E <i>e</i>);
</big></dt>
<dd><b>Returns:</b><br>
an array of length 1 with first element set to <pre style="display:inline;" class="d_inline_code"><i>e</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.opAssign"></a>@trusted void <u>opAssign</u>(typeof(this) <i>rhs</i>);
</big></dt>
<dd>Copy assignment.<br><br>

</dd>
<dt><big><a name="Array.dup"></a>const nothrow @trusted typeof(this) <u>dup</u>();
</big></dt>
<dd><b>Returns:</b><br>
shallow duplicate of <pre style="display:inline;" class="d_inline_code">this</pre>.<br><br>

</dd>
<dt><big><a name="Array.defaultInitialize"></a>void <u>defaultInitialize</u>(E <i>zeroValue</i> = E.init);
</big></dt>
<dd>Default-initialize all elements to <pre style="display:inline;" class="d_inline_code"><i>zeroValue</i></pre>..<br><br>

</dd>
<dt><big><a name="Array.this.2"></a>nothrow @trusted this(R)(R <i>values</i>, bool <i>assumeSortedParameter</i> = false) if (isInputRange!R);
</big></dt>
<dd>Construct from InputRange <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>.
        If <pre style="display:inline;" class="d_inline_code"><i>values</i></pre> are sorted <pre style="display:inline;" class="d_inline_code"><i>assumeSortedParameter</i></pre> is <b>true</b>.<br><br>

</dd>
<dt><big><a name="Array.reserve"></a>pure nothrow @trusted void <u>reserve</u>(size_t <i>n</i>);
</big></dt>
<dd>Reserve room for <pre style="display:inline;" class="d_inline_code"><i>n</i></pre> elements at store <pre style="display:inline;" class="d_inline_code">_storePtr</pre>.<br><br>

</dd>
<dt><big><a name="Array.compress"></a>pure nothrow @trusted void <u>compress</u>();
</big></dt>
<dd>Pack/Compress storage.<br><br>

</dd>
<dt><big><a name="Array.clear"></a>void <u>clear</u>();
</big></dt>
<dd>Destruct.<br><br>

</dd>
<dt><big><a name="Array.linearPopAtIndex"></a>@trusted ContainerElementType!(typeof(this), E) <u>linearPopAtIndex</u>(size_t <i>index</i>);
</big></dt>
<dd>Removal doesn't need to care about ordering.<br><br>

</dd>
<dt><big><a name="Array.linearPopFront"></a>@trusted ContainerElementType!(typeof(this), E) <u>linearPopFront</u>();
</big></dt>
<dd>Removal doesn't need to care about ordering.<br><br>

</dd>
<dt><big><a name="Array.popBack"></a>@safe void <u>popBack</u>();
</big></dt>
<dd>Removal doesn't need to care about ordering.<br><br>

</dd>
<dt><big><a name="Array.backPop"></a>E <u>backPop</u>();
</big></dt>
<dd>Pop back element and return it.<br><br>

</dd>
<dt><big><a name="Array.popBackN"></a>@safe void <u>popBackN</u>(size_t <i>count</i>);
</big></dt>
<dd>Pop last <pre style="display:inline;" class="d_inline_code"><i>count</i></pre> back elements.<br><br>

</dd>
<dt><big><a name="Array.pushBack"></a>void <u>pushBack</u>(Us...)(Us <i>values</i>) if (<i>values</i>.length &gt;= 1 &amp;&amp; allSatisfy!(isElementAssignable, Us));
<br>void <u>pushBack</u>(R)(R <i>values</i>) if (isInputRange!R &amp;&amp; !isArray!R &amp;&amp; !isMyArray!R &amp;&amp; isElementAssignable!(ElementType!R));
</big></dt>
<dd>Push back (append) <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.pushBack.2"></a>@trusted void <u>pushBack</u>(A)(A <i>values</i>) if (isArray!A &amp;&amp; isElementAssignable!(ElementType!A));
</big></dt>
<dd>ditto.<br><br>

</dd>
<dt><big><a name="Array.pushBack.3"></a>@trusted void <u>pushBack</u>(A)(ref const A <i>values</i>) if (isMyArray!A &amp;&amp; isElementAssignable!(ElementType!A));
</big></dt>
<dd>ditto.<br><br>

</dd>
<dt><big><a name="Array.contains"></a>const nothrow @nogc bool <u>contains</u>(U)(U <i>value</i>);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> iff this <u>contains</u> <pre style="display:inline;" class="d_inline_code"><i>value</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.lowerBound"></a>inout auto <u>lowerBound</u>(SearchPolicy sp = SearchPolicy.binarySearch, U)(U <i>e</i>);
</big></dt>
<dd>Wrapper for <pre style="display:inline;" class="d_inline_code">std.range.SortedRange.<u>lowerBound</u></pre> when this <pre style="display:inline;" class="d_inline_code">ordering</pre> is sorted.<br><br>

</dd>
<dt><big><a name="Array.upperBound"></a>inout auto <u>upperBound</u>(SearchPolicy sp = SearchPolicy.binarySearch, U)(U <i>e</i>);
</big></dt>
<dd>Wrapper for <pre style="display:inline;" class="d_inline_code">std.range.SortedRange.<u>upperBound</u></pre> when this <pre style="display:inline;" class="d_inline_code">ordering</pre> is sorted.<br><br>

</dd>
<dt><big><a name="Array.linearInsert"></a>bool[Us.length] <u>linearInsert</u>(SearchPolicy sp = SearchPolicy.binarySearch, Us...)(Us <i>values</i>) if (<i>values</i>.length &gt;= 1 &amp;&amp; allSatisfy!(isElementAssignable, Us));
</big></dt>
<dd>Inserts <pre style="display:inline;" class="d_inline_code"><i>values</i></pre> into <pre style="display:inline;" class="d_inline_code">this</pre> ordered set.
<br><br>
<b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">bool</pre>-array with same length as <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>, where i:th
                <pre style="display:inline;" class="d_inline_code">bool</pre> value is set if <pre style="display:inline;" class="d_inline_code">value[i]</pre> wasn't previously in <pre style="display:inline;" class="d_inline_code">this</pre>.<br><br>

</dd>
<dt><big><a name="Array.opSlice"></a>auto <u>opSlice</u>();
<br>auto <u>opSlice</u>(this This)(size_t <i>i</i>, size_t <i>j</i>);
<br><a name="Array.opIndex"></a>ref @trusted auto <u>opIndex</u>(size_t <i>i</i>);
</big></dt>
<dd>Slice operator must be const when ordered.
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Array.front"></a>ref @trusted const(E) <u>front</u>();
</big></dt>
<dd>Get <u>front</u> element (as constant reference to preserve ordering).
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Array.back"></a>ref @trusted const(E) <u>back</u>();
</big></dt>
<dd>Get <u>back</u> element (as constant reference to preserve ordering).
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="Array.empty"></a>const @safe bool <u>empty</u>();
</big></dt>
<dd>Check if <u>empty</u>.<br><br>

</dd>
<dt><big><a name="Array.length"></a>const @safe size_t <u>length</u>();
<br><a name="Array.opDollar"></a>alias <u>opDollar</u> = length;
</big></dt>
<dd>Get <u>length</u>.<br><br>

</dd>
<dt><big><a name="Array.shrinkTo"></a>@safe void <u>shrinkTo</u>(size_t <i>length</i>);
<br><a name="Array.opDollar.2"></a>alias <u>opDollar</u> = length;
</big></dt>
<dd>Shrink <i>length</i> to <pre style="display:inline;" class="d_inline_code"><i>length</i></pre>.<br><br>

</dd>
<dt><big><a name="Array.reservedLength"></a>const @safe size_t <u>reservedLength</u>();
</big></dt>
<dd>Get length of reserved store.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
