<html><head>
        <!-- Generated by Ddoc from symbolic.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>symbolic</title>
        </head><body>
        <h1>symbolic</h1>
Symbolic (Regular) Expressions and Predicate Logic.
<br><br>
Syntax is similar to Emacs' sregex, rx.
<br><br>

   String patterns are matched by their raw bytes for now.

<br><br>
<b>License:</b><br>
.
<br><br>
<b>Authors:</b><br>
 
<br><br>

   TODO
   Overload operators &amp; (and), ! (not),
<br><br>

   TODO Add pattern for expressing inference with <pre style="display:inline;" class="d_inline_code">infer</pre>
   (infer
    ((x instanceOf X) &amp;
     (X subClassOf Y))
     (x instaceOf Y))
<br><br>

   TODO
   Variables are either
   -  (ignore)
   - `x<pre style="display:inline;" class="d_inline_code">, _</pre>y`, etc
   - 'x', 'y'
   - !0, !1, ..., !(n-1)
<br><br>

   infer(rel!<pre style="display:inline;" class="d_inline_code">desire</pre>(!<pre style="display:inline;" class="d_inline_code">x</pre>, !<pre style="display:inline;" class="d_inline_code">y</pre>) &amp;&amp;
         rel!<pre style="display:inline;" class="d_inline_code">madeOf</pre>(!<pre style="display:inline;" class="d_inline_code">z</pre>, !<pre style="display:inline;" class="d_inline_code">y</pre>),
         rel!<pre style="display:inline;" class="d_inline_code">desire</pre>(!<pre style="display:inline;" class="d_inline_code">x</pre>, !<pre style="display:inline;" class="d_inline_code">z</pre>))
<br><br>

   TODO Support variables of specific types and inference using predicate logic:
        infer(and(fact(var!'x', rel'desire', var!'y'),
                  fact(var!'z', opt(rel'madeOf',
                              rel'instanceOf'), var!'y'))),
              pred(var!'x', rel'desire', var!'z'
              ))
<br><br>

   TODO Make returns from factory functions immutable.
   TODO Reuse return patterns from Lit
<br><br>

   TODO
   const s = seq(<pre style="display:inline;" class="d_inline_code">al.</pre>.lit,
   <pre style="display:inline;" class="d_inline_code">pha</pre>.lit);
   const t = <pre style="display:inline;" class="d_inline_code">al</pre>.lit ~ <pre style="display:inline;" class="d_inline_code">pha</pre>.lit;
   assert(s !is t);
   assert(equal(s, t));<br><br>

<dl><dt><big><a name="Patt"></a>class <u>Patt</u>;
</big></dt>
<dd>Base Pattern.<br><br>

<dl><dt><big><a name="Patt.matchU"></a>final const pure nothrow ref @safe auto <u>matchU</u>(in ubyte[] <i>haystack</i>, size_t <i>soff</i> = 0);
</big></dt>
<dd>Match  with  at Offset .
<br><br>
<b>Returns:</b><br>
Matched slice or [] if not match.<br><br>

</dd>
<dt><big><a name="Patt.findAt"></a>final const pure nothrow @safe const(ubyte[]) <u>findAt</u>(in string <i>haystack</i>, size_t <i>soff</i> = 0);
</big></dt>
<dd>Find  in String  at Offset .<br><br>

</dd>
<dt><big><a name="Patt.findRawAt"></a>const pure nothrow @safe const(ubyte[]) <u>findRawAt</u>(in ubyte[] <i>haystack</i>, size_t <i>soff</i> = 0, in Patt[] <i>enders</i> = []);
</big></dt>
<dd>Find  in Raw Bytes  at Offset .<br><br>

</dd>
<dt><big><a name="Patt.minLength"></a>const pure nothrow @property @safe size_t <u>minLength</u>();
</big></dt>
<dd><b>Returns:</b><br>
minimum possible instance length.<br><br>

</dd>
<dt><big><a name="Patt.maxLength"></a>const pure nothrow @property @safe size_t <u>maxLength</u>();
</big></dt>
<dd><b>Returns:</b><br>
maximum possible instance length.<br><br>

</dd>
<dt><big><a name="Patt.isFixed"></a>const pure nothrow @property @safe bool <u>isFixed</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> if all possible instances have same length.<br><br>

</dd>
<dt><big><a name="Patt.isConstant"></a>const pure nothrow @property @safe bool <u>isConstant</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> if all possible instances have same length.<br><br>

</dd>
<dt><big><a name="Patt.getConstant"></a>const pure nothrow @property @safe const(ubyte[]) <u>getConstant</u>();
</big></dt>
<dd><b>Returns:</b><br>
data if literal otherwise empty array.<br><br>

</dd>
<dt><big><a name="Patt.mandatories"></a>pure nothrow @property @safe Lit[] <u>mandatories</u>();
</big></dt>
<dd>Get All Literals that must match a given source  in order for  to match  somewhere.<br><br>

</dd>
<dt><big><a name="Patt.optionals"></a>pure nothrow @property @safe Lit[] <u>optionals</u>();
</big></dt>
<dd>Get Optional Literals that may match a given source  if 
        matches  somewhere.<br><br>

</dd>
<dt><big><a name="Patt._parent"></a>protected Patt <u>_parent</u>;
</big></dt>
<dd>Parenting (Super) Pattern.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Lit"></a>class <u>Lit</u>: <u>symbolic.Patt</u>;
</big></dt>
<dd>Literal Pattern with Cached Binary Byte Histogram.<br><br>

<dl><dt><big><a name="Lit.singlesHist"></a>pure nothrow @property @safe SinglesHist <u>singlesHist</u>();
</big></dt>
<dd>Get (Cached) (Binary) Histogram over single elements contained in this .<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Acronym"></a>class <u>Acronym</u>: <u>symbolic.Patt</u>;
</big></dt>
<dd>Word/Symbol <u>Acronym</u> Pattern.<br><br>

</dd>
<dt><big><a name="Any"></a>class <u>Any</u>: <u>symbolic.Patt</u>;
</big></dt>
<dd><u>Any</u> Byte.<br><br>

</dd>
<dt><big><a name="SPatt"></a>abstract class <u>SPatt</u>: <u>symbolic.Patt</u>;
</big></dt>
<dd>Abstract Super Pattern.<br><br>

</dd>
<dt><big><a name="Seq"></a>class <u>Seq</u>: <u>symbolic.SPatt</u>;
</big></dt>
<dd>Sequence of Patterns.<br><br>

</dd>
<dt><big><a name="Alt"></a>class <u>Alt</u>: <u>symbolic.SPatt</u>;
</big></dt>
<dd>Alternative of Patterns in .<br><br>

<dl><dt><big><a name="Alt.atU"></a>const pure nothrow @safe size_t <u>atU</u>(in ubyte[] <i>haystack</i>, size_t <i>soff</i>, out size_t <i>alt_hix</i>);
</big></dt>
<dd>Get Length of hit at index <i>soff</i> in <i>haystack</i> or size_t.max if none.<br><br>

</dd>
<dt><big><a name="Alt.findRawAt"></a>const pure nothrow @safe const(ubyte[]) <u>findRawAt</u>(in ubyte[] <i>haystack</i>, size_t <i>soff</i> = 0, in Patt[] <i>enders</i> = []);
</big></dt>
<dd>Find  in  at Offset .<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="SPatt1"></a>abstract class <u>SPatt1</u>: <u>symbolic.Patt</u>;
</big></dt>
<dd>Abstract Singleton Super Pattern.<br><br>

</dd>
<dt><big><a name="Opt"></a>class <u>Opt</u>: <u>symbolic.SPatt1</u>;
</big></dt>
<dd>Optional Sub Pattern  times.<br><br>

</dd>
<dt><big><a name="Rep"></a>class <u>Rep</u>: <u>symbolic.SPatt1</u>;
</big></dt>
<dd>Repetition Sub Pattern  times.<br><br>

</dd>
<dt><big><a name="kwd"></a>Seq <u>kwd</u>(Arg)(Arg <i>arg</i>);
</big></dt>
<dd>Keyword .<br><br>

</dd>
<dt><big><a name="Clause"></a>class <u>Clause</u>: <u>symbolic.SPatt1</u>;
</big></dt>
<dd>Pattern Paired with Prefix and Suffix.<br><br>

</dd>
<dt><big><a name="shebangLine"></a>pure nothrow ref @safe auto <u>shebangLine</u>(Patt <i>interpreter</i>);
</big></dt>
<dd>Create Matcher for a UNIX Shell  Pattern.
<br><br>
<b>Example:</b><br>
#!/bin/env rdmd
    See also: https://en.wikipedia.org/wiki/Shebang_(Unix)<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Per Nordl√∂w 2014-.
</small>
        </body></html>
