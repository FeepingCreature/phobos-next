<html><head>
        <!-- Generated by Ddoc from /home/per/Work/justd/phobos-next/src/algorithm_ex.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>algorithm_ex</title>
        </head><body>
        <h1>algorithm_ex</h1>
Extensions to std.algorithm.
<br><br>
<b>License:</b><br>
.
<br><br>
<b>Authors:</b><br>
<br><br>

<dl><dt><big><a name="either"></a>CommonType!Ts <u>either</u>(Ts...)(lazy Ts <i>a</i>) if (<i>a</i>.length &gt;= 1);
</big></dt>
<dd><b>Returns:</b><br>
First Argument (element of ) whose implicit conversion to
    <pre style="display:inline;" class="d_inline_code">bool</pre> is <pre style="display:inline;" class="d_inline_code">true</pre>.
<br><br>

    Similar to behaviour of <pre style="display:inline;" class="d_inline_code">or</pre> operator in dynamic languages such as Lisp's (or
    <i>a</i>...) and Python's <i>a</i> or ....
<br><br>

    TODO Is inout Conversion!T the correct return value?

<br><br>
<b>NOTE:</b><br>
Lazy parameters are currently marked as throw which makes it
    impossible to mark <u>either</u>() as nothrow. Issue at
<br><br>
<b>https:</b><br>
//issues.dlang.org/show_bug.cgi?id=12647<br><br>

</dd>
<dt><big><a name="either.2"></a>ref auto <u>either</u>(Ts...)(ref Ts <i>a</i>) if (<i>a</i>.length &gt;= 1 &amp;&amp; allSameType!Ts);
</big></dt>
<dd>This overload enables, when possible, lvalue return.
    TODO should we limit this template to <pre style="display:inline;" class="d_inline_code"><i>a</i>.length &gt;= 2</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>immutable</font> p = 1, q = 2;
<font color=blue>auto</font> pq = <u>either</u>(p, q);
<font color=blue>assert</font>(pq == 1);

<font color=blue>assert</font>(<u>either</u>(3) == 3);
<font color=blue>assert</font>(<u>either</u>(3, 4) == 3);
<font color=blue>assert</font>(<u>either</u>(0, 4) == 4);
<font color=blue>assert</font>(<u>either</u>(0, 0) == 0);
<font color=blue>assert</font>(<u>either</u>(<font color=red>``</font>, <font color=red>`a`</font>) == <font color=red>``</font>);
string s = <font color=blue>null</font>;
<font color=blue>assert</font>(<u>either</u>(s, <font color=red>`a`</font>) == <font color=red>`a`</font>);
<font color=blue>assert</font>(<u>either</u>(<font color=red>`a`</font>, <font color=red>``</font>) == <font color=red>`a`</font>);
<font color=blue>immutable</font> a2 = [1, 2];
<font color=blue>assert</font>(<u>either</u>(a2) == a2);
<font color=blue>assert</font>(<u>either</u>([0, 1], [1, 2]) == [0, 1]);
<font color=blue>assert</font>(<u>either</u>([0, 1], [1]) == [0, 1]);
<font color=blue>assert</font>(<u>either</u>(<font color=red>`a`</font>, <font color=red>`b`</font>) == <font color=red>`a`</font>);

<font color=blue>int</font> x = 1, y = 2;
<u>either</u>(x, y) = 3;
<font color=blue>assert</font>(x == 3);
<font color=blue>assert</font>(y == 2);
</pre>
<br><br>
</dd>
<dt><big><a name="every"></a>CommonType!T <u>every</u>(T...)(lazy T <i>a</i>) if (T.length &gt;= 1);
</big></dt>
<dd><b>Returns:</b><br>
Last Argument if all arguments implicitly bool-convert to <pre style="display:inline;" class="d_inline_code">true</pre>
    otherwise <pre style="display:inline;" class="d_inline_code">CommonType!T.init</pre>.
<br><br>

    Similar to behaviour of <pre style="display:inline;" class="d_inline_code">and</pre> operator in dynamic languages such as of
    Lisp's <pre style="display:inline;" class="d_inline_code">(and <i>a</i>...)</pre> and Python's <pre style="display:inline;" class="d_inline_code"><i>a</i> and ....</pre>.
<br><br>

    TODO Is inout Conversion!T the correct return value?<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<u>every</u>(3) == 3);
<font color=blue>assert</font>(<u>every</u>(3, 4) == 4);
<font color=blue>assert</font>(<u>every</u>(0, 4) == 0);
<font color=blue>assert</font>(<u>every</u>(0, 0) == 0);
<font color=blue>assert</font>(<u>every</u>([0, 1], [1, 2]) == [1, 2]);
<font color=blue>assert</font>(<u>every</u>([0, 1], [1]) == [1]);
<font color=blue>assert</font>(<u>every</u>(<font color=red>`a`</font>, <font color=red>`b`</font>) == <font color=red>`b`</font>);
<font color=blue>assert</font>(<u>every</u>(<font color=red>``</font>, <font color=red>`b`</font>) == <font color=red>`b`</font>);
<font color=blue>assert</font>(<u>every</u>(<font color=blue>cast</font>(string)<font color=blue>null</font>, <font color=red>`b`</font>) == <font color=blue>cast</font>(string)<font color=blue>null</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="tryEvery"></a>CommonType!T[] <u>tryEvery</u>(S, T...)(ref S <i>whole</i>, lazy T <i>parts</i>) if (T.length &gt;= 1);
</big></dt>
<dd>Evaluate all  possibly digesting .
    If all values of  implicitly convert to bool <b>true</b> return the
    values as an array, otherwise restore <i>whole</i> and return <b>null</b>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> <i>whole</i> = <font color=red>`xyz`</font>;
<font color=blue>import</font> std.algorithm: skipOver;

<font color=blue>assert</font>(<i>whole</i>.<u>tryEvery</u>(<i>whole</i>.skipOver('x'),
                      <i>whole</i>.skipOver('z')) == []); <font color=green>// failing match
</font><font color=blue>assert</font>(<i>whole</i> == <font color=red>`xyz`</font>); <font color=green>// should restore whole
</font>
<font color=blue>assert</font>(<i>whole</i>.<u>tryEvery</u>(<i>whole</i>.skipOver('x'),
                      <i>whole</i>.skipOver('y'),
                      <i>whole</i>.skipOver('w')) == []); <font color=green>// failing match
</font><font color=blue>assert</font>(<i>whole</i> == <font color=red>`xyz`</font>); <font color=green>// should restore whole
</font>
<font color=blue>assert</font>(<i>whole</i>.<u>tryEvery</u>(<i>whole</i>.skipOver('x'),
                      <i>whole</i>.skipOver('y')) == [<font color=blue>true</font>, <font color=blue>true</font>]); <font color=green>// successful match
</font><font color=blue>assert</font>(<i>whole</i> == <font color=red>`z`</font>); <font color=green>// should digest matching part
</font></pre>
<br><br>
</dd>
<dt><big><a name="hasContents"></a>bool <u>hasContents</u>(T)(in T <i>a</i>);
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> iff  has <i>a</i> value containing meaningful information.<br><br>

</dd>
<dt><big><a name="reset"></a>ref @trusted auto <u>reset</u>(T)(ref T <i>a</i>);
</big></dt>
<dd>Reset  to its default value.
    See also: std.typecons.Nullable.nullify<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font> x = 42;
x.<u>reset</u>;
<font color=blue>assert</font>(x == x.init);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.typecons : Nullable;
<font color=blue>auto</font> n = Nullable!(size_t,
                   size_t.max)();
<font color=blue>import</font> predicates : isUntouched;
<font color=blue>assert</font>(n.isUntouched);
n = 0;
<font color=blue>assert</font>(!n.isUntouched);
<font color=blue>assert</font>(n == 0);
n.<u>reset</u>;
<font color=blue>assert</font>(n.isUntouched);
</pre>
<br><br>
</dd>
<dt><big><a name="findInOrder"></a>auto <u>findInOrder</u>(alias pred = "a == b", alias finder = find, R, E...)(R <i>haystack</i>, E <i>needles</i>);
</big></dt>
<dd>Find  In Order in .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.range : empty;
<font color=blue>assert</font>(<font color=red>`a b c`</font>.<u>findInOrder</u>(<font color=red>`a`</font>, <font color=red>`b`</font>, <font color=red>`c`</font>));
<font color=blue>assert</font>(<font color=red>`b a`</font>.<u>findInOrder</u>(<font color=red>`a`</font>, <font color=red>`b`</font>).empty);
</pre>
<br><br>
</dd>
<dt><big><a name="overlapInOrder"></a>inout(T[]) <u>overlapInOrder</u>(T)(inout(T[]) <i>a</i>, inout(T[]) <i>b</i>);
</big></dt>
<dd><b>Returns:</b><br>
Slice Overlap of  and  in order given by arguments.<br><br>

</dd>
<dt><big><a name="overlap"></a>inout(T[]) <u>overlap</u>(T)(inout(T[]) <i>a</i>, inout(T[]) <i>b</i>);
</big></dt>
<dd><b>Returns:</b><br>
Slice Overlap of  and  in any order.
    Deprecated by: std.array.<u>overlap</u><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [-11_111, 11, 22, 333_333];
<font color=blue>const</font> y = [-22_222, 441, 555, 66];

<font color=blue>assert</font>(!<u>overlap</u>(x, y));
<font color=blue>assert</font>(!<u>overlap</u>(y, x));

<font color=blue>auto</font> x01 = x[0..1];
<font color=blue>auto</font> x12 = x[1..2];
<font color=blue>auto</font> x23 = x[2..3];

<font color=green>// sub-ranges should overlap completely
</font><font color=blue>assert</font>(<u>overlap</u>(x, x12) == x12);
<font color=blue>assert</font>(<u>overlap</u>(x, x01) == x01);
<font color=blue>assert</font>(<u>overlap</u>(x, x23) == x23);
<font color=green>// and commutate f(a,b) == f(b,a)
</font><font color=blue>assert</font>(<u>overlap</u>(x01, x) == x01);
<font color=blue>assert</font>(<u>overlap</u>(x12, x) == x12);
<font color=blue>assert</font>(<u>overlap</u>(x23, x) == x23);
</pre>
<br><br>
</dd>
<dt><big><a name="overlaps"></a>@trusted bool <u>overlaps</u>(T)(const(T)[] <i>r1</i>, const(T)[] <i>r2</i>);
</big></dt>
<dd>Helper for overlap().
    Copied from std.array with simplified return expression.<br><br>

</dd>
<dt><big><a name="isSymmetric"></a>bool <u>isSymmetric</u>(R)(R <i>range</i>, size_t <i>minLength</i> = 0) if (isBidirectionalRange!R);
</big></dt>
<dd><b>Returns:</b><br>
If <i>range</i> is a palindrome larger than .
    See also: http://forum.dlang.org/thread/dlfeiszyweafpjiocplf@forum.dlang.org#post-vpzuaqxvtdpzpeuorxdl:40forum.dlang.org
    See also: https://stackoverflow.com/questions/21849580/equality-operator-in-favour-of-std-range-equal
<br><br>
<b>TODO:</b><br>
Test graphemes in <pre style="display:inline;" class="d_inline_code">string</pre> and <pre style="display:inline;" class="d_inline_code">wstring</pre>.
    TODO Move to Phobos<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<font color=red>`dallassallad`</font>.<u>isSymmetric</u>);
<font color=blue>assert</font>(!<font color=red>`ab`</font>.<u>isSymmetric</u>);
<font color=blue>assert</font>(<font color=red>`a`</font>.<u>isSymmetric</u>);
<font color=blue>assert</font>(<font color=red>`åäå`</font>.<u>isSymmetric</u>);
<font color=blue>assert</font>(<font color=red>`áá`</font>.<u>isSymmetric</u>);
<font color=blue>assert</font>(<font color=red>`åäå`</font>.<u>isSymmetric</u>(3));
<font color=blue>assert</font>(!<font color=red>`åäå`</font>.<u>isSymmetric</u>(4));
<font color=blue>assert</font>(<font color=red>``</font>.<u>isSymmetric</u>);
<font color=blue>assert</font>([1, 2, 2, 1].<u>isSymmetric</u>);
<font color=blue>assert</font>(![1, 2, 2, 1].<u>isSymmetric</u>(5));
</pre>
<br><br>
</dd>
<dt><big><a name="isAnagramOf"></a>auto <u>isAnagramOf</u>(R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>) if (isInputRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; areEquable!(ElementType!R1, ElementType!R2));
</big></dt>
<dd>Return <b>true</b> if  is an Anagram of .
    Equal arguments are not considered to be an anagrams of each other.
<br><br>
TODO Is there a faster way of calculating anagrams?
    TODO Allow const input
    TODO Move to Phobos std.algorithm.sorting.
    TODO Should requirement isInputRange be relaxed?
<br><br>

    Note that implementations in http://rosettacode.org/wiki/Anagrams#D doesn't
    correctly handle multi-byte encoded characters in string and wstring.<br><br>

</dd>
<dt><big><a name="windowedReduce"></a>ref auto <u>windowedReduce</u>(Reduction reduction = Reduction.forwardDifference, R)(R <i>range</i>) if (isInputRange!R);
</big></dt>
<dd>Generalized Windowed Reduce.
    See also: https://stackoverflow.com/questions/21004944/forward-difference-algorithm
    See also: http://forum.dlang.org/thread/ujouqtqeehkegmtaxebg@forum.dlang.org#post-lczzsypupcfigttghkwx:40forum.dlang.org
    See also: http://rosettacode.org/wiki/Forward_difference#D<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.datetime: Clock, SysTime, Duration;
<font color=blue>import</font> std.algorithm.iteration: map;
SysTime[] times;
<font color=blue>const</font> n = 4;
<font color=blue>foreach</font> (i; 0..n)
    times ~= Clock.currTime;
<font color=blue>version</font>(print) dln(times);
<font color=blue>auto</font> spans = times.<u>windowedReduce</u>!(Reduction.forwardDifference);
<font color=blue>version</font>(print) dln(spans);
<font color=green>// dln(*(cast(ulong*)&amp;(spans.front)));
</font><font color=blue>version</font>(print) dln(Duration.sizeof);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>immutable</font> i = [1, 4, 9, 17];
<font color=blue>import</font> std.algorithm: equal;
<font color=blue>assert</font>(i.<u>windowedReduce</u>!(Reduction.forwardDifference).equal ([+3, +5, +8]));
<font color=blue>assert</font>(i.<u>windowedReduce</u>!(Reduction.backwardDifference).equal([-3, -5, -8]));
<font color=blue>assert</font>(i.<u>windowedReduce</u>!(Reduction.sum).equal ([+5, +13, +26]));
<font color=blue>assert</font>([1].<u>windowedReduce</u>.empty);
<font color=blue>version</font>(print) dln(i.<u>windowedReduce</u>!(Reduction.sum));
</pre>
<br><br>
</dd>
<dt><big><a name="forwardDifference"></a>auto <u>forwardDifference</u>(R)(R <i>r</i>) if (isInputRange!R);
</big></dt>
<dd>Compute Forward Difference of .
<br><br>
TODO Is there a difference between whether R <i>r</i> is immutable, const or
    mutable?
<br><br>

    TODO If <i>r</i> contains only one element return empty range.
<br><br>

    See also: https://stackoverflow.com/questions/21004944/forward-difference-algorithm
    See also: http://forum.dlang.org/thread/ujouqtqeehkegmtaxebg@forum.dlang.org#post-lczzsypupcfigttghkwx:40forum.dlang.org
    See also: http://rosettacode.org/wiki/Forward_difference#D<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.array: array;

<font color=blue>auto</font> x = [<font color=blue>long</font>.max, 0, 1];
<font color=blue>auto</font> y = x.<u>forwardDifference</u>;

<font color=blue>version</font>(print) dln(y);

<font color=green>// import msgpack;
</font><font color=green>// version(print) dln(y.pack);
</font><font color=green>// version(print) dln(y.array.pack);
</font></pre>
<br><br>
</dd>
<dt><big><a name="apply"></a>auto <u>apply</u>(alias fun, N)(N <i>n</i>) if (arityMin0!fun &amp;&amp; !is(ReturnType!fun == void) &amp;&amp; isIntegral!N);
</big></dt>
<dd>Create Range of Elements Generated by .
<br><br>
Use for example to generate random instances of return value of fun.
<br><br>

    TODO I believe we need arityMin, arityMax trait here<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.datetime: Clock, SysTime, Duration;
<font color=blue>import</font> std.algorithm.iteration: map;
<font color=blue>import</font> std.array: array;
<font color=blue>const</font> <i>n</i> = 3;
<font color=blue>auto</font> times = <i>n</i>.<u>apply</u>!(Clock.currTime).array;
<font color=blue>version</font>(print) dln(times);
<font color=blue>auto</font> spans = times.forwardDifference;
<font color=blue>version</font>(print) dln(spans);
</pre>
<br><br>
</dd>
<dt><big><a name="orderInPlace"></a>@trusted void <u>orderInPlace</u>(T...)(ref T <i>t</i>);
</big></dt>
<dd>In Place Ordering (in Sorted Order) of all Elements .
    See also: https://stackoverflow.com/questions/21102646/in-place-ordering-of-elements/
    See also: http://forum.dlang.org/thread/eweortsmcmibppmvtriw@forum.dlang.org#post-eweortsmcmibppmvtriw:40forum.dlang.org<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = 2, y = 1;
<u>orderInPlace</u>(x, y);
<font color=blue>assert</font>(x == 1);
<font color=blue>assert</font>(y == 2);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = 3, y = 1, z = 2;
<u>orderInPlace</u>(x, y, z);
<font color=blue>assert</font>(x == 1);
<font color=blue>assert</font>(y == 2);
<font color=blue>assert</font>(z == 3);
</pre>
<br><br>
</dd>
<dt><big><a name="sort"></a>template <u>sort</u>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable)</big></dt>
<dd>Allow Static Arrays to be sorted without [].
    See also: http://forum.dlang.org/thread/jhzurojjnlkatjdgcfhg@forum.dlang.org<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font>[5] a = [ 9, 5, 1, 7, 3 ];
<font color=blue>int</font>[]  b = [ 4, 2, 1, 6, 3 ];
<u>sort</u>(a);
<u>sort</u>(b);
</pre>
<br><br>
</dd>
<dt><big><a name="stableSort"></a>pure ref auto <u>stableSort</u>(T)(auto ref T <i>a</i>) if (isRandomAccessRange!T);
</big></dt>
<dd>Stable Variant of Quick Sort.
    See also: http://forum.dlang.org/thread/gjuvmrypvxeebvztszpr@forum.dlang.org<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> random_ex: randInPlace;
<font color=blue>const</font> n = 2^^16;
<font color=blue>auto</font> <i>a</i> = <font color=blue>new</font> <font color=blue>int</font>[n];
<i>a</i>.randInPlace;
<font color=blue>auto</font> b = <i>a</i>.dup;
<i>a</i>[].<u>stableSort</u>;
<font color=blue>import</font> std.algorithm: sort;
sort(b);
<font color=blue>assert</font>(<i>a</i> == b);
</pre>
<br><br>
</dd>
<dt><big><a name="doTimes"></a>void <u>doTimes</u>(uint <i>n</i>, lazy void <i>expr</i>);
</big></dt>
<dd>Execute Expression  the same way  times.<br><br>

</dd>
<dt><big><a name="doTimes.2"></a>void <u>doTimes</u>(uint n)(lazy void <i>expr</i>);
</big></dt>
<dd>Execute Expression  <i>inline</i> the same way  times.
     must be a constant known at compile time.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font> i = 0;
<u>doTimes</u>!4(i++);
<font color=blue>assert</font>(i == 4);
</pre>
<br><br>
</dd>
<dt><big><a name="times"></a>void <u>times</u>(alias action, N)(N <i>n</i>) if (isCallable!action &amp;&amp; isIntegral!N &amp;&amp; arity!action &lt;= 1);
</big></dt>
<dd>Execute Expression  the same way  <u>times</u>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> <i>n</i> = 10;
<font color=blue>int</font> sum = 0;
10.<u>times</u>!({ sum++; });
<font color=blue>assert</font>(sum == <i>n</i>);
</pre>
<br><br>
</dd>
<dt><big><a name="zipWith"></a>auto <u>zipWith</u>(alias fun, Ranges...)(Ranges <i>ranges</i>) if (Ranges.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, Ranges));
</big></dt>
<dd>Zip  together with operation .
    TODO Remove when Issue 8715 is fixed providing <u>zipWith</u><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> x = [1, 2, 3];
<font color=blue>import</font> std.array: array;
<font color=blue>assert</font>(<u>zipWith</u>!<font color=red>`a+b`</font>(x, x).array == [2, 4, 6]);
<font color=blue>assert</font>(<u>zipWith</u>!((a, b) =&gt; a + b)(x, x).array == [2, 4, 6]);
<font color=blue>assert</font>(<u>zipWith</u>!<font color=red>`a+b+c`</font>(x, x, x).array == [3, 6, 9]);
</pre>
<br><br>
</dd>
<dt><big><a name="Pair"></a>template <u>Pair</u>(T, U)</big></dt>
<dd><u>Pair</u>. TODO std.typecons<br><br>

</dd>
<dt><big><a name="pair"></a>auto <u>pair</u>(T, U)(in T <i>t</i>, in U <i>u</i>);
</big></dt>
<dd>Instantiator for .<br><br>

</dd>
<dt><big><a name="Triple"></a>template <u>Triple</u>(T, U, V)</big></dt>
<dd><u>Triple</u>. TODO std.typecons<br><br>

</dd>
<dt><big><a name="triple"></a>auto <u>triple</u>(T, U, V)(in T <i>t</i>, in U <i>u</i>, in V <i>v</i>);
</big></dt>
<dd>Instantiator for .<br><br>

</dd>
<dt><big><a name="Quadruple"></a>template <u>Quadruple</u>(T, U, V, W)</big></dt>
<dd><u>Quadruple</u>. TODO std.typecons<br><br>

</dd>
<dt><big><a name="quadruple"></a>auto <u>quadruple</u>(T, U, V, W)(in T <i>t</i>, in U <i>u</i>, in V <i>v</i>, in W <i>w</i>);
</big></dt>
<dd>Instantiator for .<br><br>

</dd>
<dt><big><a name="Limits"></a>struct <u>Limits</u>(T);
</big></dt>
<dd>Limit/Span (Min,Max) Pair.
<br><br>
<b>Todo:</b><br>
Decide on either Span, MinMax or <u>Limits</u>
    See also: https://stackoverflow.com/questions/21241878/generic-span-type-in-phobos<br><br>

<dl><dt><big><a name="Limits.include"></a>nothrow ref auto <u>include</u>(in T <i>a</i>);
</big></dt>
<dd>Expand Limits to <u>include</u> .<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="areColinear"></a>bool <u>areColinear</u>(T)(T <i>a</i>, T <i>b</i>);
</big></dt>
<dd>Check if  and  are colinear.<br><br>

</dd>
<dt><big><a name="fibonacci"></a>auto <u>fibonacci</u>(T = int)(T <i>nth</i> = 0) if (isIntLike!T);
</big></dt>
<dd> Numbers (Infinite Range).
    See also: http://forum.dlang.org/thread/dqlrfoxzsppylcgljyyf@forum.dlang.org#post-mailman.1072.1350619455.5162.digitalmars-d-learn:40puremagic.com
    See also: https://www.reddit.com/r/programming/comments/rif9x/uniform_function_call_syntax_for_the_d/<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.range: take;
<font color=blue>import</font> std.algorithm: equal;
<font color=blue>assert</font>(<u>fibonacci</u>.take(10).equal([1, 1, 2, 3, 5, 8, 13, 21, 34, 55]));
<font color=blue>assert</font>(1.<u>fibonacci</u>.take(9).equal([1, 2, 3, 5, 8, 13, 21, 34, 55]));
</pre>
<br><br>
</dd>
<dt><big><a name="expand"></a>template <u>expand</u>(alias array, size_t idx = 0) if (isStaticArray!(typeof(array)))</big></dt>
<dd>Expand Static  into a parameter arguments (AliasSeq!).
    See also: http://forum.dlang.org/thread/hwellpcaomwbpnpofzlx@forum.dlang.org?page=1<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>void</font> foo(<font color=blue>int</font> a, <font color=blue>int</font> b, <font color=blue>int</font> c)
{
    <font color=blue>import</font> std.stdio: writefln;
    <font color=blue>version</font>(print) writefln(<font color=red>"a: %s, b: %s, c: %s"</font>, a, b, c);
}
<font color=blue>int</font>[3] arr = [1, 2, 3];
foo(<u>expand</u>!arr);
</pre>
<br><br>
</dd>
<dt><big><a name="str"></a>pure @safe string <u>str</u>(T)(in T <i>a</i>);
</big></dt>
<dd>Python Style To-String-Conversion Alias.<br><br>

</dd>
<dt><big><a name="len"></a>auto <u>len</u>(T)(in T <i>a</i>);
</big></dt>
<dd>Python Style Length Alias.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.algorithm.iteration: map;
<font color=blue>import</font> std.array: array;
<font color=blue>assert</font>(([42].map!str).array == [<font color=red>`42`</font>]);
</pre>
<br><br>
</dd>
<dt><big><a name="set"></a>ref T <u>set</u>(string member, T, U)(auto ref T <i>a</i>, in U <i>value</i>) if (isAggregateType!T &amp;&amp; hasMember!(T, member));
</big></dt>
<dd>Generic Member Setter.
    See also: http://forum.dlang.org/thread/fdjkijrtduraaajlxxne@forum.dlang.org<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>class</font> C { <font color=blue>int</font> x, y, z, w; }
<font color=blue>auto</font> c = <font color=blue>new</font> C().<u>set</u>!<font color=red>`x`</font>(11).<u>set</u>!<font color=red>`w`</font>(44);
<font color=blue>assert</font>(c.x == 11);
<font color=blue>assert</font>(c.w == 44);
</pre>
<br><br>
</dd>
<dt><big><a name="split"></a>auto <u>split</u>(alias pred, R)(R <i>haystack</i>) if (isForwardRange!R);
</big></dt>
<dd>Simpler variant of Phobos' .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.algorithm: equal;
<font color=blue>import</font> std.ascii: isDigit;
<font color=blue>assert</font>(<font color=red>`aa1bb`</font>.<u>split</u>!(a =&gt; a.isDigit) == tuple(<font color=red>`aa`</font>, <font color=red>`1`</font>, <font color=red>`bb`</font>));
<font color=blue>assert</font>(<font color=red>`aa1`</font>.<u>split</u>!(a =&gt; a.isDigit) == tuple(<font color=red>`aa`</font>, <font color=red>`1`</font>, <font color=red>``</font>));
<font color=blue>assert</font>(<font color=red>`1bb`</font>.<u>split</u>!(a =&gt; a.isDigit) == tuple(<font color=red>``</font>, <font color=red>`1`</font>, <font color=red>`bb`</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="splitBefore"></a>auto <u>splitBefore</u>(alias pred, R)(R <i>haystack</i>) if (isForwardRange!R);
</big></dt>
<dd>Simpler variant of Phobos' .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.algorithm: equal;
<font color=blue>import</font> std.ascii: isDigit;
<font color=blue>assert</font>(<font color=red>`11ab`</font>.<u>splitBefore</u>!(a =&gt; !a.isDigit) == tuple(<font color=red>`11`</font>, <font color=red>`ab`</font>));
<font color=blue>assert</font>(<font color=red>`ab`</font>.<u>splitBefore</u>!(a =&gt; !a.isDigit) == tuple(<font color=red>``</font>, <font color=red>`ab`</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="findPopBefore"></a>auto <u>findPopBefore</u>(alias pred = "a == b", R1, R2)(ref R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
</big></dt>
<dd>Variant of  that destructively pops everything up to,
    not including,  from .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> <i>haystack</i> = <font color=red>`xy`</font>;
<font color=blue>auto</font> <i>needle</i> = <font color=red>`z`</font>;
<font color=blue>auto</font> pop = <i>haystack</i>.<u>findPopBefore</u>(<i>needle</i>);
<font color=blue>assert</font>(pop == <font color=red>`xy`</font>);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> <i>haystack</i> = <font color=red>`xyz`</font>;
<font color=blue>auto</font> <i>needle</i> = <font color=red>`y`</font>;
<font color=blue>auto</font> pop = <i>haystack</i>.<u>findPopBefore</u>(<i>needle</i>);
<font color=blue>assert</font>(pop == <font color=red>`x`</font>);
<font color=blue>assert</font>(<i>haystack</i> == <font color=red>`yz`</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="findPopAfter"></a>auto <u>findPopAfter</u>(alias pred = "a == b", R1, R2)(ref R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
</big></dt>
<dd>Variant of  that destructively pops everything up to,
    including,  from .<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> source = <font color=red>`xyz`</font>;
<font color=blue>auto</font> <i>haystack</i> = source;
<font color=blue>auto</font> <i>needle</i> = <font color=red>`y`</font>;
<font color=blue>auto</font> pop = <i>haystack</i>.<u>findPopAfter</u>(<i>needle</i>);
<font color=blue>assert</font>(pop == <font color=red>`xy`</font>);
<font color=blue>assert</font>(<i>haystack</i> == <font color=red>`z`</font>);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> source = <font color=red>`xy`</font>;
<font color=blue>auto</font> <i>haystack</i> = source;
<font color=blue>auto</font> <i>needle</i> = <font color=red>`z`</font>;
<font color=blue>auto</font> pop = <i>haystack</i>.<u>findPopAfter</u>(<i>needle</i>);
<font color=blue>assert</font>(pop <font color=blue>is</font> <font color=blue>null</font>);
<font color=blue>assert</font>(!pop);
<font color=blue>assert</font>(<i>haystack</i> == source);
</pre>
<br><br>
</dd>
<dt><big><a name="findFirstOfAnyInOrder"></a>Tuple!(R, size_t) <u>findFirstOfAnyInOrder</u>(alias pred = "a == b", R)(R <i>haystack</i>, const R[] <i>needles</i>);
</big></dt>
<dd>Find First Occurrence any of  in .
    Like to std.algorithm.find but takes an array of <i>needles</i> as argument instead
    of a variadic list of key needle arguments.
   Return found range plus index into <i>needles</i> starting at 1 upon.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<font color=red>`abc`</font>.<u>findFirstOfAnyInOrder</u>([<font color=red>`x`</font>]) == tuple(<font color=red>``</font>, 0UL));
<font color=blue>assert</font>(<font color=red>`abc`</font>.<u>findFirstOfAnyInOrder</u>([<font color=red>`a`</font>]) == tuple(<font color=red>`abc`</font>, 1UL));
<font color=blue>assert</font>(<font color=red>`abc`</font>.<u>findFirstOfAnyInOrder</u>([<font color=red>`c`</font>]) == tuple(<font color=red>`c`</font>, 1UL));
<font color=blue>assert</font>(<font color=red>`abc`</font>.<u>findFirstOfAnyInOrder</u>([<font color=red>`a`</font>, <font color=red>`b`</font>]) == tuple(<font color=red>`abc`</font>, 1UL));
<font color=blue>assert</font>(<font color=red>`abc`</font>.<u>findFirstOfAnyInOrder</u>([<font color=red>`a`</font>, <font color=red>`b`</font>]) == tuple(<font color=red>`abc`</font>, 1UL));
<font color=blue>assert</font>(<font color=red>`abc`</font>.<u>findFirstOfAnyInOrder</u>([<font color=red>`x`</font>, <font color=red>`b`</font>]) == tuple(<font color=red>`bc`</font>, 2UL));
</pre>
<br><br>
</dd>
<dt><big><a name="areStrictlyOrdered"></a>bool <u>areStrictlyOrdered</u>(Ts...)(Ts <i>args</i>) if (<i>args</i>.length &gt;= 2 &amp;&amp; haveCommonType!Ts);
</big></dt>
<dd>Return <b>true</b> if all arguments  are strictly ordered,
    that is <i>args</i>[0] &lt; <i>args</i>[1] &lt; <i>args</i>[2] &lt; ... .
<br><br>
<b>TODO:</b><br>
CT-variant
    See also: http://forum.dlang.org/thread/wzsdhzycwqyrvqmmttix@forum.dlang.org?page=2#post-vprvhifglfegnlvzqmjj:40forum.dlang.org<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <u>areStrictlyOrdered</u>()));
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <u>areStrictlyOrdered</u>(1)));
<font color=blue>assert</font>(<u>areStrictlyOrdered</u>(1, 2, 3));
<font color=blue>assert</font>(!<u>areStrictlyOrdered</u>(1, 3, 2));
<font color=blue>assert</font>(!<u>areStrictlyOrdered</u>(1, 2, 2));
<font color=blue>assert</font>(<u>areStrictlyOrdered</u>('a', 'b', 'c'));
</pre>
<br><br>
</dd>
<dt><big><a name="areUnstrictlyOrdered"></a>bool <u>areUnstrictlyOrdered</u>(Ts...)(Ts <i>args</i>) if (<i>args</i>.length &gt;= 2 &amp;&amp; haveCommonType!Ts);
</big></dt>
<dd>Return <b>true</b> if all arguments  are unstrictly ordered,
    that is <i>args</i>[0] &lt;= <i>args</i>[1] &lt;= <i>args</i>[2] &lt;= ... .
<br><br>
<b>TODO:</b><br>
CT-variant
    See also: http://forum.dlang.org/thread/wzsdhzycwqyrvqmmttix@forum.dlang.org?page=2#post-vprvhifglfegnlvzqmjj:40forum.dlang.org<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <u>areUnstrictlyOrdered</u>()));
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <u>areUnstrictlyOrdered</u>(1)));
<font color=blue>assert</font>(<u>areUnstrictlyOrdered</u>(1, 2, 2, 3));
<font color=blue>assert</font>(!<u>areUnstrictlyOrdered</u>(1, 3, 2));
<font color=blue>assert</font>(<u>areUnstrictlyOrdered</u>('a', 'b', 'c'));
</pre>
<br><br>
</dd>
<dt><big><a name="append"></a>ref R <u>append</u>(R, Args...)(ref R <i>data</i>, auto ref Args <i>args</i>) if (<i>args</i>.length &gt;= 1);
</big></dt>
<dd>Append Arguments $(<i>args</i>) to .
    TODO Add support for other Random Access Ranges such as std.container.Array
    See also: http://forum.dlang.org/thread/mevnosveagdiswkxtbrv@forum.dlang.org?page=1<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font>[] <i>data</i>;
<font color=blue>import</font> std.range: only, iota;

<i>data</i>.<u>append</u>(-1, 0, only(1, 2, 3), iota(4, 9));
<font color=blue>assert</font>(<i>data</i> == [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8]);

<i>data</i>.<u>append</u>(9, 10);
<font color=blue>assert</font>(<i>data</i> == [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

<i>data</i>.<u>append</u>([11, 12], [13, 14]);
<font color=blue>assert</font>(<i>data</i> == [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]);

<font color=green>// int[3] d;
</font><font color=green>// data.append(d, d);
</font>
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { <i>data</i>.<u>append</u>(); }));
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.container: Array;
<font color=blue>import</font> std.algorithm: equal;

Array!<font color=blue>int</font> <i>data</i>;

<i>data</i>.<u>append</u>(-1);
<font color=blue>assert</font>(equal(<i>data</i>[], [-1]));

<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { <i>data</i>.<u>append</u>(); }));
</pre>
<br><br>
</dd>
<dt><big><a name="distinct"></a>auto <u>distinct</u>(R)(R <i>r</i>) if (isInputRange!(Unqual!R));
</big></dt>
<dd>Distinct Elements of .
<br><br>
See also: http://forum.dlang.org/thread/jufggxqwzhlsmhshtnfj@forum.dlang.org?page=2
   See also: http://dpaste.dzfl.pl/7b4b37b490a7<br><br>

</dd>
<dt><big><a name="staticArray"></a>@property @safe auto <u>staticArray</u>();
</big></dt>
<dd>Make a static array.<br><br>

</dd>
<dt><big><a name="isAmong"></a>bool <u>isAmong</u>(alias pred = (a, b) =&gt; a == b, Value, Values...)(Value <i>value</i>, Values <i>values</i>) if (Values.length != 0);
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code"><i>value</i></pre> is equal to any of <pre style="display:inline;" class="d_inline_code"><i>values</i></pre>, <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<font color=red>`b`</font>.<u>isAmong</u>(<font color=red>`a`</font>, <font color=red>`b`</font>));
<font color=blue>assert</font>(!<font color=red>`c`</font>.<u>isAmong</u>(<font color=red>`a`</font>, <font color=red>`b`</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="isAmong.2"></a>template <u>isAmong</u>(values...) if (isExpressionTuple!values)</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code">value</pre> is equal to any of <pre style="display:inline;" class="d_inline_code">values</pre>, <pre style="display:inline;" class="d_inline_code">false</pre> otherwise.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<font color=red>`b`</font>.<u>isAmong</u>!(<font color=red>`a`</font>, <font color=red>`b`</font>));
<font color=blue>assert</font>(!<font color=red>`c`</font>.<u>isAmong</u>!(<font color=red>`a`</font>, <font color=red>`b`</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="elementCombinations"></a>alias <u>elementCombinations</u> = std.algorithm.setops.cartesianProduct(R1, R2)(R1 range1, R2 range2) if (!allSatisfy!(isForwardRange, R1, R2) || anySatisfy!(isInfinite, R1, R2));
</big></dt>
<dd>More descriptive alias.<br><br>

</dd>
<dt><big><a name="resetAllMembers"></a>void <u>resetAllMembers</u>(T)(T <i>c</i>) if (is(T == class));
</big></dt>
<dd>Reset all members in aggregate instance .
    See also: http://forum.dlang.org/post/ckitmpguywfitgadfpkv@forum.dlang.org
    See also: http://forum.dlang.org/post/fbs8b5bu@digitalmars.com<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>class</font> C
{
    <font color=blue>this</font> (<font color=blue>int</font> a, <font color=blue>int</font> b, string <i>c</i>)
    {
        <font color=blue>this</font>.a = a;
        <font color=blue>this</font>.b = b;
        <font color=blue>this</font>.<i>c</i> = <i>c</i>;
    }
    <font color=blue>int</font> a; <font color=blue>int</font> b; string <i>c</i>;
}
<font color=blue>void</font> f(C <i>c</i>)
{
    <i>c</i>.<u>resetAllMembers</u>();
}
<font color=blue>auto</font> <i>c</i> = <font color=blue>new</font> C(1, 2, <font color=red>"3"</font>);
<font color=blue>assert</font>(<i>c</i>.a == 1);
<font color=blue>assert</font>(<i>c</i>.b == 2);
<font color=blue>assert</font>(<i>c</i>.<i>c</i> == <font color=red>"3"</font>);
f(<i>c</i>);
<font color=blue>assert</font>(<i>c</i>.a == 0);
<font color=blue>assert</font>(<i>c</i>.b == 0);
<font color=blue>assert</font>(<i>c</i>.<i>c</i> == <font color=blue>null</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="isLinearRamp"></a>bool <u>isLinearRamp</u>(R)(R <i>r</i>, size_t <i>step</i> = 1) if (isInputRange!R &amp;&amp; isIntegral!(ElementType!R));
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> contains strictly values that are strictly increase
    with the increment <pre style="display:inline;" class="d_inline_code"><i>step</i></pre>.
    See also: http://forum.dlang.org/post/mqjyhvqxepgfljpkxvmd@forum.dlang.org<br><br>

</dd>
<dt><big><a name="countsExactly"></a>bool <u>countsExactly</u>(R)(R <i>r</i>, size_t <i>exactCount</i>) if (isInputRange!R);
</big></dt>
<dd>Check if <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> counts to exactly <pre style="display:inline;" class="d_inline_code"><i>exactCount</i></pre> elements.<br><br>

</dd>
<dt><big><a name="countsAtLeast"></a>bool <u>countsAtLeast</u>(R)(R <i>r</i>, size_t <i>minCount</i>) if (isInputRange!R);
</big></dt>
<dd>Check if <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> counts to at least <pre style="display:inline;" class="d_inline_code"><i>minCount</i></pre> elements.<br><br>

</dd>
<dt><big><a name="countsAtMost"></a>bool <u>countsAtMost</u>(R)(R <i>r</i>, size_t <i>maxCount</i>) if (isInputRange!R);
</big></dt>
<dd>Check if <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> counts to at most <pre style="display:inline;" class="d_inline_code"><i>maxCount</i></pre> elements.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>void</font> test(R)(R x) <font color=blue>if</font> (isInputRange!R)
{
    <font color=blue>import</font> std.algorithm : count;
    <font color=blue>const</font> n = x.count;

    <font color=green>// below
</font>    <font color=blue>foreach</font> (<font color=blue>const</font> i; 0 .. n)
    {
        <font color=blue>assert</font>(x.countsAtLeast(i));
        <font color=blue>assert</font>(!x.countsExactly(i));
        <font color=blue>assert</font>(!x.<u>countsAtMost</u>(i));
    }

    <font color=green>// at
</font>    <font color=blue>assert</font>(x.countsAtLeast(n));
    <font color=blue>assert</font>(x.countsExactly(n));
    <font color=blue>assert</font>(x.<u>countsAtMost</u>(n));

    <font color=green>// above
</font>    <font color=blue>foreach</font> (<font color=blue>const</font> i; n + 1 .. n + 10)
    {
        <font color=blue>assert</font>(!x.countsAtLeast(i));
        <font color=blue>assert</font>(!x.countsExactly(i));
        <font color=blue>assert</font>(x.<u>countsAtMost</u>(i));
    }
}

<font color=blue>import</font> std.algorithm : filter;
<font color=blue>import</font> std.range : iota;
<font color=blue>import</font> std.array : array;

test(3.iota.filter!(x =&gt; <font color=blue>true</font>));
test(3.iota.array);
</pre>
<br><br>
</dd>
<dt><big><a name="equalLength"></a>pure nothrow @nogc @safe bool <u>equalLength</u>(R, Ss...)(const R <i>r</i>, const Ss <i>ss</i>) if (Ss.length &gt;= 1 &amp;&amp; allSatisfy!(hasLength, R, Ss));
</big></dt>
<dd><b>Returns:</b><br>
<pre style="display:inline;" class="d_inline_code">true</pre> if <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> and all <pre style="display:inline;" class="d_inline_code"><i>ss</i></pre> all have equal length.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<u>equalLength</u>([1], [2], [3]));
<font color=blue>assert</font>(!<u>equalLength</u>([1, 1], [2], [3]));
<font color=blue>assert</font>(!<u>equalLength</u>([1], [2, 2], [3]));
<font color=blue>assert</font>(!<u>equalLength</u>([1], [2], [3, 3]));
</pre>
<br><br>
</dd>
<dt><big><a name="collect"></a>Container <u>collect</u>(Container, Range)(Range <i>r</i>);
</big></dt>
<dd>Collect/Gather the elements of <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> into a <pre style="display:inline;" class="d_inline_code">Container</pre> and return it.
    TODO Use std.container.util.make instead?: https://dlang.org/phobos/std_container_util.html#.make
    TODO Rename <pre style="display:inline;" class="d_inline_code">container</pre> to <pre style="display:inline;" class="d_inline_code">output</pre>?
    TODO Support Set-containers via <pre style="display:inline;" class="d_inline_code">insert</pre> aswell, or add <pre style="display:inline;" class="d_inline_code">alias put = insert</pre> to them?
    TODO What about Appender?
    TODO Rename to <pre style="display:inline;" class="d_inline_code"><u>collect</u></pre> to <pre style="display:inline;" class="d_inline_code">gather</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.range : iota;
<font color=blue>import</font> std.algorithm.iteration : map;
<font color=blue>import</font> std.algorithm : filter;
<font color=blue>import</font> std.algorithm.comparison : equal;
<font color=blue>import</font> algorithm_ex : <u>collect</u>;

<font color=blue>alias</font> E = <font color=blue>int</font>;
<font color=blue>alias</font> V = E[];
<font color=blue>const</font> n = 1000;

<font color=blue>auto</font> x = 0.iota(n).<u>collect</u>!V;

<font color=blue>assert</font>([0, 1, 2].map!(_ =&gt; _^^2).<u>collect</u>!V.equal([0, 1, 4]));
<font color=blue>assert</font>([0, 1, 2, 3].filter!(_ =&gt; _ &amp; 1).<u>collect</u>!V.equal([1, 3]));
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Per Nordlöw 2014-.
</small>
        </body></html>
