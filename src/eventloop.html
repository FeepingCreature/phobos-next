<html><head>
        <!-- Generated by Ddoc from /home/per/Work/justd/arsd/eventloop.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>arsd.eventloop</title>
        </head><body>
        <h1>arsd.eventloop</h1>
crappy event loop for linux<br><br>

<dl><dt><big><a name="isValidEventListener"></a>enum bool <u>isValidEventListener</u>(T);
</big></dt>
<dd>Valid event listeners must be callable and take exactly one argument. The type of argument determines the type of event.<br><br>

</dd>
<dt><big><a name="addOnIdle"></a>void <u>addOnIdle</u>(T)(T <i>t</i>) if (isCallable!T &amp;&amp; ParameterTypeTuple!T.length == 0);
</big></dt>
<dd>Calls this function once every time the event system is idle<br><br>

</dd>
<dt><big><a name="removeOnIdle"></a>void <u>removeOnIdle</u>(T)(T <i>t</i>) if (isCallable!T &amp;&amp; ParameterTypeTuple!T.length == 0);
</big></dt>
<dd>Removes an idle handler (added with addOnIdle)<br><br>

</dd>
<dt><big><a name="TimerHandle"></a>struct <u>TimerHandle</u>;
</big></dt>
<dd>An opaque type to reference an active timer<br><br>

</dd>
<dt><big><a name="setTimeout"></a>TimerHandle <u>setTimeout</u>(T)(T <i>t</i>, int <i>msecsWait</i>, int <i>count</i> = 1) if (isCallable!T &amp;&amp; ParameterTypeTuple!T.length == 0);
</big></dt>
<dd>Sets a timer, one-shot by default. Count tells how many times the timer will fire. Set to zero for a continuously firing timer<br><br>

</dd>
<dt><big><a name="setInterval"></a>TimerHandle <u>setInterval</u>(T)(T <i>t</i>, int <i>msecsInterval</i>) if (isCallable!T &amp;&amp; ParameterTypeTuple!T.length == 0);
</big></dt>
<dd>Sets a continuously firing interval. It will call the function as close to the interval as it can, but it won'<i>t</i> let triggers stack up.<br><br>

</dd>
<dt><big><a name="clearTimeout"></a>void <u>clearTimeout</u>(TimerHandle <i>handle</i>);
</big></dt>
<dd>Clears a timer<br><br>

</dd>
<dt><big><a name="exit"></a>@nogc void <u>exit</u>();
</big></dt>
<dd>Sends an <u>exit</u> event to the loop. The loop will break when it sees this event, ignoring any events after that point.<br><br>

</dd>
<dt><big><a name="addListener"></a>void <u>addListener</u>(T)(T <i>t</i>) if (isValidEventListener!T);
</big></dt>
<dd>Adds an event listener. Event listeners must be functions that take exactly one argument.<br><br>

</dd>
<dt><big><a name="removeListener"></a>bool <u>removeListener</u>(T)(T <i>t</i>) if (isValidEventListener!T);
</big></dt>
<dd>Removes an event listener. Returns <b>true</b> if the event was actually found.<br><br>

</dd>
<dt><big><a name="sendSync"></a>void <u>sendSync</u>(T)(T <i>t</i>);
</big></dt>
<dd>Sends a message to the listeners immediately, bypassing the event loop<br><br>

</dd>
<dt><big><a name="send"></a>void <u>send</u>(T)(T <i>t</i>);
</big></dt>
<dd>Send a message to the event loop<br><br>

</dd>
<dt><big><a name="loop"></a>void <u>loop</u>();
</big></dt>
<dd>Runs the <u>loop</u>, dispatching events to registered listeners as they come in<br><br>

</dd>
<dt><big><a name="FileEventDispatcher"></a>struct <u>FileEventDispatcher</u>;
</big></dt>
<dd>Since the lowest level event for files only allows one handler, but can send events that require a variety of different responses,
<br><br>
the <u>FileEventDispatcher</u> is available to make this easer.
<br><br>

<br><br>

<br><br>

Instead of filtering yourself, you can add files to one of these with handlers for read, write, and error on that specific handle.
<br><br>

These handlers must take either zero arguments or exactly one argument, which will be the file being handled.<br><br>

<dl><dt><big><a name="FileEventDispatcher.addFile"></a>void <u>addFile</u>(FileType, ReadEventHandler, WriteEventHandler, ErrorEventHandler)(FileType <i>handle</i>, ReadEventHandler <i>readEventHandler</i> = null, WriteEventHandler <i>writeEventHandler</i> = null, ErrorEventHandler <i>errorEventHandler</i> = null, bool <i>edgeTriggered</i> = true) if (templateCheckHelper!(is(FileType == OsFileHandle), "The FileType must be an operating system file <i>handle</i>") &amp;&amp; templateCheckHelper!(isValidFileEventDispatcherHandler!(ReadEventHandler, FileType), "The ReadEventHandler was not valid") &amp;&amp; templateCheckHelper!(isValidFileEventDispatcherHandler!(WriteEventHandler, FileType), "The WriteEventHandler was not valid") &amp;&amp; templateCheckHelper!(isValidFileEventDispatcherHandler!(ErrorEventHandler, FileType), "The ErrorEventHandler was not valid"));
</big></dt>
<dd>You can add a file to listen to here. Files can be OS handles or Phobos types. The handlers can be <b>null</b>, meaning use the default
<br><br>
(see: setDefaultHandler), or callables with zero or one argument. If they take an argument, it will be the file being handled at this time.<br><br>

</dd>
<dt><big><a name="FileEventDispatcher.HandlerDuty"></a>enum <u>HandlerDuty</u>: int;
</big></dt>
<dd>What should this default handler work on?<br><br>

<dl><dt><big><a name="FileEventDispatcher.HandlerDuty.read"></a><u>read</u></big></dt>
<dd><u>read</u> events<br><br>

</dd>
<dt><big><a name="FileEventDispatcher.HandlerDuty.write"></a><u>write</u></big></dt>
<dd><u>write</u> events<br><br>

</dd>
<dt><big><a name="FileEventDispatcher.HandlerDuty.error"></a><u>error</u></big></dt>
<dd><u>error</u> events<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="FileEventDispatcher.setDefaultHandler"></a>void <u>setDefaultHandler</u>(T)(HandlerDuty <i>duty</i>, T <i>handler</i>) if (isValidFileEventDispatcherHandler!(T, OsFileHandle));
</big></dt>
<dd>Sets a default <i>handler</i>, used for file events where the custom <i>handler</i> on addFile was <b>null</b><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="addFileEventListeners"></a>void <u>addFileEventListeners</u>(T...)(T <i>t</i>);
</big></dt>
<dd>To add listeners for file events on a specific file dispatcher, use this.
<br><br>
See FileEventDispatcher.addFile for the parameters
<br><br>

<br><br>

<br><br>

When you get an event that a file is ready, you MUST read all of it until
<br><br>

exhausted (that is, read until it would block - you could use select() for
<br><br>

this or set the file to nonblocking mode) because you only get an event
<br><br>

when the state changes. Failure to read it all will leave whatever is left
<br><br>

in the buffer sitting there unnoticed until even more stuff comes in.<br><br>

</dd>
<dt><big><a name="removeFileEventListeners"></a>void <u>removeFileEventListeners</u>(OsFileHandle <i>handle</i>);
</big></dt>
<dd>Removes the file from event handling<br><br>

</dd>
<dt><big><a name="FileEvents"></a>enum <u>FileEvents</u>: int;
</big></dt>
<dd>If you add a file to the event loop, which events are you interested in?<br><br>

<dl><dt><big><a name="FileEvents.read"></a><u>read</u></big></dt>
<dd>the file is ready to be <u>read</u> from<br><br>

</dd>
<dt><big><a name="FileEvents.write"></a><u>write</u></big></dt>
<dd>the file is ready to be written to<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="addFileToLoop"></a>void <u>addFileToLoop</u>(OsFileHandle <i>fd</i>, int <i>events</i>, bool <i>edgeTriggered</i> = true);
</big></dt>
<dd>Adds a file handle to the event loop. When the handle has data available to read
<br><br>
(if <i>events</i> &amp; FileEvents.read) or write (if <i>events</i> &amp; FileEvents.write), a message
<br><br>

FileReadyToRead and/or FileReadyToWrite will be dispatched.
<br><br>

<br><br>


<br><br>
<b>note:</b><br>
the file you add should be nonblocking and you should be sure anything in the
<br><br>

buffers is already handled, since you won't get <i>events</i> for data that already exists<br><br>

</dd>
<dt><big><a name="openNewEventPipes"></a>void <u>openNewEventPipes</u>();
</big></dt>
<dd>you generally won't want to call this, but if you fork()
<br><br>
and then try to use the thing without exec(), you might want
<br><br>

new pipes so the events don't get mixed up.<br><br>

</dd>
<dt><big><a name="FileReadyToRead"></a>struct <u>FileReadyToRead</u>;
</big></dt>
<dd>This is a low level event that is dispatched when a listened file (see: addFileToLoop) is ready to be read
<br><br>
You should read as much as possible without blocking from the file now, as a future event may not be fired for left over data<br><br>

</dd>
<dt><big><a name="FileReadyToWrite"></a>struct <u>FileReadyToWrite</u>;
</big></dt>
<dd>This is a low level event that is dispatched when a listened file (see: addFileToLoop) is ready to be written to<br><br>

</dd>
<dt><big><a name="FileError"></a>struct <u>FileError</u>;
</big></dt>
<dd>This is a low level event that is dispatched when a listened file (see: addFileToLoop) has an error<br><br>

</dd>
<dt><big><a name="FileHup"></a>struct <u>FileHup</u>;
</big></dt>
<dd>This is a low level event that is dispatched when a listened file (see: addFileToLoop) has a hang up event<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
