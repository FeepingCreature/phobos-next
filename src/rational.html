<html><head>
        <!-- Generated by Ddoc from /home/per/Work/justd/phobos-next/src/rational.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>rational</title>
        </head><body>
        <h1>rational</h1>
This module contains an implementation of <u>rational</u> numbers that is templated
 on the underlying integer type.  It can be used with either builtin fixed
 width integers or arbitrary precision integers.  All relevant operators are
 overloaded for both <u>rational</u>-<u>rational</u> and <u>rational</u>-integer operations.
<br><br>
<b>Synopsis:</b><br>
<pre class="d_code"><font color=green>// Compute pi using the generalized continued fraction approximation.
</font><font color=blue>import</font> std.bigint, std.<u>rational</u>, std.stdio;

<font color=blue>enum</font> maxTerm = 30;

Rational!(BigInt) getTerm(<font color=blue>int</font> termNumber)
{
    <font color=blue>auto</font> addFactor = 2 * termNumber - 1;

    <font color=blue>if</font> (termNumber == maxTerm)
    {
        <font color=blue>return</font> <u>rational</u>(BigInt(addFactor));
    }

    <font color=blue>auto</font> termNumberSquared = BigInt(termNumber * termNumber);
    <font color=blue>auto</font> continued = termNumberSquared / getTerm(termNumber + 1);

    continued += addFactor;
    <font color=blue>return</font> continued;
}

<font color=blue>void</font> main()
{
    <font color=blue>auto</font> pi = <u>rational</u>(BigInt(4)) / getTerm(1);

    <font color=green>// Display the result in rational form.
</font>    writeln(pi);

    <font color=green>// Display the decimal equivalent, which is accurate to 18 decimal places.
</font>    writefln(<font color=red>"%.18f"</font>, <font color=blue>cast</font>(<font color=blue>real</font>) pi);
}
</pre>
<br><br>


<br><br>
<b>Author:</b><br>
David Simcha
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a><br><br>

<dl><dt><big><a name="isIntegerLike"></a>template <u>isIntegerLike</u>(T)</big></dt>
<dd>Checks whether  is structurally an integer, i.e. whether it supports
 all of the operations an integer type should support.  Does not check the
 nominal type of .  In particular, for a mutable type  the
 following must compile:
<br><br>
<pre class="d_code">T n;
n = 2;
n &lt;&lt;= 1;
n &gt;&gt;= 1;
n += n;
n += 2;
n *= n;
n *= 2;
n /= n;
n /= 2;
n -= n;
n -= 2;
n %= 2;
n %= n;
<font color=blue>bool</font> foo = n &lt; 2;
<font color=blue>bool</font> bar = n == 2;
<font color=blue>bool</font> goo = n &lt; n + 1;
<font color=blue>bool</font> tar = n == n;
</pre>
<br><br>

 while for a non-mutable type, the above must compile for its unqualified,
 mutable variant.
<br><br>

 All built-in D integers and character types and  are
 integer-like by this definition.
<br><br>

 TODO Why not use isIntegral here instead?<br><br>

</dd>
<dt><big><a name="isRational"></a>enum auto <u>isRational</u>(T);
</big></dt>
<dd>Checks if  has the basic properties of a rational type, i.e.  it has a
 numerator and a denominator.<br><br>

</dd>
<dt><big><a name="CommonInteger"></a>template <u>CommonInteger</u>(I1, I2) if (isIntegerLike!I1 &amp;&amp; isIntegerLike!I2)</big></dt>
<dd>Returns a Common Integral Type between  and .  This is defined
 as the type returned by I1.init * I2.init.<br><br>

</dd>
<dt><big><a name="CommonRational"></a>template <u>CommonRational</u>(R1, R2)</big></dt>
<dd>Returns a Common Rational Type between  and , which
 will be a Rational based on the CommonInteger of their underlying
 integer types (or just on the CommonInteger of ($D R1) and ,
 if they themselves are integers).<br><br>

</dd>
<dt><big><a name="rational"></a>Rational!(CommonInteger!(I1, I2)) <u>rational</u>(I1, I2)(I1 <i>i1</i>, I2 <i>i2</i>) if (isIntegerLike!I1 &amp;&amp; isIntegerLike!I2);
<br>Rational!I <u>rational</u>(I)(I <i>val</i>) if (isIntegerLike!I);
</big></dt>
<dd>Implements <u>rational</u> numbers on top of whatever integer type is specified
 by the user.  The integer type used may be any type that behaves as an integer.
 Specifically,  must return <b>true</b>, the integer type must
 have value semantics, and the semantics of all integer operations must follow
 the normal rules of integer arithmetic.
<br><br>
A regular integer can be converted to <u>rational</u> type simply by passing it as
 a single argument.  In this case the denominator will simply be set to 1.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> r1 = <u>rational</u>(BigInt(<font color=red>"314159265"</font>), BigInt(<font color=red>"27182818"</font>));
<font color=blue>auto</font> r2 = <u>rational</u>(BigInt(<font color=red>"8675309"</font>), BigInt(<font color=red>"362436"</font>));
r1 += r2;
<font color=blue>assert</font>(r1 == <u>rational</u>(BigInt(<font color=red>"174840986505151"</font>),
                      BigInt(<font color=red>"4926015912324"</font>)));

<font color=green>// Print result.  Prints:
</font><font color=green>// "174840986505151/4926015912324"
</font>writeln(r1);

<font color=green>// Print result in decimal form.  Prints:
</font><font color=green>// "35.4934"
</font>writeln(<font color=blue>cast</font>(<font color=blue>real</font>) r1);

<font color=blue>auto</font> r3 = <u>rational</u>(10);
<font color=blue>assert</font>(r3.numerator == 10);
<font color=blue>assert</font>(r3.denominator == 1);
<font color=blue>assert</font>(r3 == 10);
</pre>
<br><br>

</dd>
<dt><big><a name="Rational"></a>struct <u>Rational</u>(Int) if (isIntegerLike!Int);
</big></dt>
<dd>The struct that implements rational numbers.  All relevant operators
 (addition, subtraction, multiplication, division, exponentiation by a
 non-negative integer, equality and comparison) are overloaded.  The second
 operand for all binary operators except exponentiation may be either another
  or another integer type.<br><br>

<dl><dt><big><a name="Rational.invert"></a>typeof(this) <u>invert</u>();
</big></dt>
<dd>Fast inversion, equivalent to 1 / rational.<br><br>

</dd>
<dt><big><a name="Rational.opCast"></a>F <u>opCast</u>(F)() if (isFloatingPoint!F);
</big></dt>
<dd>Convert to floating point representation.<br><br>

</dd>
<dt><big><a name="Rational.opCast.2"></a>I <u>opCast</u>(I)() if (isIntegerLike!I &amp;&amp; is(typeof(cast(I)Int.init)));
</big></dt>
<dd>Casts  to an integer by truncating the fractional part.
 Equivalent to , and then casting it to type .<br><br>

</dd>
<dt><big><a name="Rational.numerator"></a>@property Int <u>numerator</u>();
</big></dt>
<dd>Returns the <u>numerator</u>.<br><br>

</dd>
<dt><big><a name="Rational.denominator"></a>@property Int <u>denominator</u>();
</big></dt>
<dd>Returns the <u>denominator</u>.<br><br>

</dd>
<dt><big><a name="Rational.integerPart"></a>@property Int <u>integerPart</u>();
</big></dt>
<dd>Returns the integer part of this rational, with any remainder truncated.<br><br>

</dd>
<dt><big><a name="Rational.fractionPart"></a>@property typeof(this) <u>fractionPart</u>();
</big></dt>
<dd>Returns the fractional part of this rational.<br><br>

</dd>
<dt><big><a name="Rational.toString"></a>string <u>toString</u>();
</big></dt>
<dd>Returns a string representation of  in the form a/b.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="toRational"></a>Rational!Int <u>toRational</u>(Int)(real <i>floatNum</i>, real <i>epsilon</i> = 1e-08);
</big></dt>
<dd>Convert a floating point number to a  based on integer type .
 Allows an error tolerance of .  (Default  = 1e-8.)
<br><br>
 must be greater than 1.0L / long.max.

<br><br>
<b>Throws:</b><br>
Exception on infinities, NaNs, numbers with absolute value
 larger than long.max and epsilons smaller than 1.0L / long.max.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// Prints "22/7".
</font>writeln(<u>toRational</u>!<font color=blue>int</font>(PI, 1e-1));
</pre>
<br><br>

</dd>
<dt><big><a name="gcf"></a>CommonInteger!(I1, I2) <u>gcf</u>(I1, I2)(I1 <i>m</i>, I2 <i>n</i>) if (isIntegerLike!I1 &amp;&amp; isIntegerLike!I2);
</big></dt>
<dd>Find the Greatest Common Factor (GCF), aka Greatest Common Divisor (GCD), of
  and .<br><br>

</dd>
<dt><big><a name="lcm"></a>CommonInteger!(I1, I2) <u>lcm</u>(I1, I2)(I1 <i>n1</i>, I2 <i>n2</i>) if (isIntegerLike!I1 &amp;&amp; isIntegerLike!I2);
</big></dt>
<dd>Find the Least Common Multiple (LCM) of  and .<br><br>

</dd>
<dt><big><a name="floor"></a>Int <u>floor</u>(Int)(Rational!Int <i>r</i>);
</big></dt>
<dd>Returns the largest integer less than or equal to .<br><br>

</dd>
<dt><big><a name="ceil"></a>Int <u>ceil</u>(Int)(Rational!Int <i>r</i>);
</big></dt>
<dd>Returns the smallest integer greater than or equal to .<br><br>

</dd>
<dt><big><a name="round"></a>Int <u>round</u>(Int)(Rational!Int <i>r</i>);
</big></dt>
<dd>Round  to the nearest integer.  If the fractional part is exactly
 1/2,  will be rounded such that the absolute value is increased by
 rounding.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright (c) 2009-2011, David Simcha.
</small>
        </body></html>
