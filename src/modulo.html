<html><head>
        <!-- Generated by Ddoc from /home/per/Work/phobos-next/src/modulo.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>modulo</title>
        </head><body>
        <h1>modulo</h1>
<br><br>
<dl><dt><big><a name="TypeOfModulo"></a>template <u>TypeOfModulo</u>(size_t m)</big></dt>
<dd>Lookup type representing an unsigned integer in inclusive range (0 .. m - 1).
    TODO Merge with similar logic in bound.d<br><br>

</dd>
<dt><big><a name="Mod"></a>struct <u>Mod</u>(size_t m, T = TypeOfModulo!m) if (m &gt;= 1 &amp;&amp; isIntegral!T);
</big></dt>
<dd>Module type within inclusive value range (0 .. <pre style="display:inline;" class="d_inline_code">m</pre>-1).
<br><br>
Similar to Ada's modulo type <pre style="display:inline;" class="d_inline_code">0 mod m</pre>.
<br><br>

    See also: https://forum.dlang.org/post/hmrpwyqfoxwtywbznbrr@forum.dlang.org
    See also: http://codeforces.com/contest/628/submission/16212299
<br><br>

    TODO reuse ideas from bound.d
<br><br>

    TODO Add function limit()
    static if (isPowerOf2!m)
    {
    return x &amp; 2^^m - 1;
    }
    else
    {
    return x % m;
    }
<br><br>

    invariant
    {
        assert (0 &lt;= x &amp;&amp; x &lt; m);
    }
<br><br>

    called after opBinary opUnary etc similar to what is done
<br><br>
<b>http:</b><br>
//codeforces.com/contest/628/submission/16212299
<br><br>

    TODO Move to Phobos std.typecons<br><br>

<dl><dt><big><a name="Mod.this"></a>this(U)(U <i>value</i>) if (isIntegral!U);
</big></dt>
<dd>Construct from <pre style="display:inline;" class="d_inline_code"><i>value</i></pre> of unsigned integer type <pre style="display:inline;" class="d_inline_code">UI</pre>.<br><br>

</dd>
<dt><big><a name="Mod.this.2"></a>this(size_t n, U)(Mod!(n, U) <i>rhs</i>) if (m &gt;= n &amp;&amp; isIntegral!U);
</big></dt>
<dd>Construct from Mod!n, where <pre style="display:inline;" class="d_inline_code">m &gt;= n</pre>.<br><br>

</dd>
<dt><big><a name="Mod.opAssign"></a>ref auto <u>opAssign</u>(U)(U <i>value</i>) if (isIntegral!U);
</big></dt>
<dd>Assign from <pre style="display:inline;" class="d_inline_code"><i>value</i></pre> of unsigned integer type <pre style="display:inline;" class="d_inline_code">UI</pre>.<br><br>

</dd>
<dt><big><a name="Mod.opAssign.2"></a>ref auto <u>opAssign</u>(size_t n, U)(Mod!(n, U) <i>rhs</i>) if (m &gt;= n &amp;&amp; isIntegral!U);
</big></dt>
<dd>Assign from Mod!n, where <pre style="display:inline;" class="d_inline_code">m &gt;= n</pre>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="mod"></a>auto <u>mod</u>(size_t m, T = TypeOfModulo!m)(T <i>value</i>) if (m &gt;= 1);
</big></dt>
<dd>Instantiator for <pre style="display:inline;" class="d_inline_code">Mod</pre>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> m = 256;
Mod!(m, <font color=blue>ubyte</font>) ub = m - 1;
Mod!(m, <font color=blue>uint</font>) ui = m - 1;
<font color=blue>assert</font>(ub == ui);
--ub;
<font color=blue>assert</font>(ub != ui);
ui = ub;
<font color=blue>assert</font>(ub == ui);
--ui;
<font color=blue>assert</font>(ub != ui);
ub = ui;
<font color=blue>assert</font>(ub == ui);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(Mod!3(1)) ==
                 <font color=blue>typeof</font>(1.<u>mod</u>!3)));

<font color=green>// check size logic
</font><font color=blue>static</font> <font color=blue>assert</font>(Mod!(<font color=blue>ubyte</font>.max + 1).sizeof == 1);
<font color=blue>static</font> <font color=blue>assert</font>(Mod!(<font color=blue>ubyte</font>.max + 2).sizeof == 2);
<font color=blue>static</font> <font color=blue>assert</font>(Mod!(<font color=blue>ushort</font>.max + 1).sizeof == 2);
<font color=blue>static</font> <font color=blue>assert</font>(Mod!(<font color=blue>ushort</font>.max + 2).sizeof == 4);
<font color=blue>static</font> <font color=blue>assert</font>(Mod!(<font color=blue>cast</font>(size_t)<font color=blue>uint</font>.max + 1).sizeof == 4);
<font color=blue>static</font> <font color=blue>assert</font>(Mod!(<font color=blue>cast</font>(size_t)<font color=blue>uint</font>.max + 2).sizeof == 8);

<font color=green>// assert that storage defaults to packed unsigned integer
</font><font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Mod!(8, <font color=blue>ubyte</font>) == Mod!(8)));

Mod!(8, <font color=blue>ubyte</font>) x = 6;
<font color=blue>static</font> <font color=blue>assert</font>(x.min == 0);
<font color=blue>static</font> <font color=blue>assert</font>(x.max == 7);
Mod!(8, <font color=blue>ubyte</font>) y = 7;
<font color=blue>static</font> <font color=blue>assert</font>(y.min == 0);
<font color=blue>static</font> <font color=blue>assert</font>(y.max == 7);
<font color=green>// static assert(!__traits(compiles, { Mod!(8) z = 256; }));
</font><font color=green>// static assert(!__traits(compiles, { Mod!(8, ubyte) z = 256; }));
</font>
<font color=blue>assert</font>(x &lt; y);

y = 5;
y = 5L;

<font color=blue>assert</font>(y &lt; x);

<font color=blue>assert</font>(y == 5);
<font color=blue>assert</font>(y != 0);

y++;
<font color=blue>assert</font>(y == 6);
<font color=blue>assert</font>(++y == y.max);
<font color=blue>assert</font>(y++ == y.max);
<font color=blue>assert</font>(y == y.min);
<font color=blue>assert</font>(--y == y.max);
<font color=blue>assert</font>(++y == y.min);

Mod!(8, <font color=blue>uint</font>) ui8 = 7;
Mod!(256, <font color=blue>ubyte</font>) ub256 = 255;
ub256 = ui8;    <font color=green>// can assign to larger modulo from higher storage precision
</font>
Mod!(258, <font color=blue>ushort</font>) ub258 = ub256;

<font color=green>// copy construction to smaller modulo is disallowed
</font><font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { Mod!(255, <font color=blue>ubyte</font>) ub255 = ub258; }));

<font color=blue>auto</font> a = 7.<u>mod</u>!10;
<font color=blue>auto</font> b = 8.<u>mod</u>!256;
<font color=blue>auto</font> c = 257.<u>mod</u>!1000;

<font color=blue>static</font> <font color=blue>assert</font>(c.min == 0);
<font color=blue>static</font> <font color=blue>assert</font>(c.max == 999);

<font color=blue>assert</font>(a &lt; b);
<font color=blue>assert</font>(a &lt; c);

<font color=green>// assignment to larger modulo (super-type/set) is allowed
</font>b = a;
c = a;
c = b;

<font color=green>// assignment to smaller modulo (sub-type/set) is disallowed
</font><font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { a = b; }));
<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, { a = c; }));
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
Mod!(256, <font color=blue>ubyte</font>) x = 55;

x += 200;
<font color=blue>assert</font>(x == 255);

x += 1;
<font color=blue>assert</font>(x == 0);

x -= 4;
<font color=blue>assert</font>(x == 252);

<font color=blue>const</font> Mod!(256, <font color=blue>ubyte</font>) y = 55;

<font color=blue>import</font> std.traits : isAssignable;
<font color=blue>static</font> <font color=blue>assert</font>(isAssignable!(<font color=blue>typeof</font>(x), <font color=blue>typeof</font>(y)));
x = y;
</pre>
<br><br><b>Examples:</b><br>
construct from other precision
<pre class="d_code">
<font color=blue>enum</font> m = 256;
Mod!(m, <font color=blue>ubyte</font>) x = 55;
Mod!(m, <font color=blue>uint</font>) y = x;
Mod!(m, <font color=blue>ubyte</font>) z = y;
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
