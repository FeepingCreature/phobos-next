<html><head>
        <!-- Generated by Ddoc from sortn.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>sortn</title>
        </head><body>
        <h1>sortn</h1>
Fixed Length Sorting via Sorting Networks.
<br><br>
See also: http://forum.dlang.org/post/ne5m62gu5@digitalmars.com
    See also: http://cpansearch.perl.org/src/JGAMBLE/Algorithm-Networksort-1.30/lib/Algorithm/Networksort.pm
    See also: http://www.angelfire.com/blog/ronz/Articles/999SortingNetworksReferen.html

<br><br>
<b>License:</b><br>
.
<br><br>

    TODO see some sizes are not supported, we should not have holes.
    Use http://www.angelfire.com/blog/ronz/Articles/999SortingNetworksReferen.html
<br><br>

    TODO Sometimes the sort routine gets too bulky. Suggestion: also define
    networks for <pre style="display:inline;" class="d_inline_code">medianOfUpTo</pre> and <pre style="display:inline;" class="d_inline_code">medianExactly</pre>, then use them in a
    quicksort manner - first compute the median to segregate values in
    below/over the median, then make two calls to <pre style="display:inline;" class="d_inline_code">sortExactly!(n / 2)</pre>. That
    way you get to sort n values with median of n values (smaller and simpler)
    and two sorts of n / 2 values.
<br><br>

    TODO Stability of equal elements: Need template parameter <pre style="display:inline;" class="d_inline_code">equalityStability</pre>? Scalar builtin values are always stable.
<br><br>

    TODO There should be a notion of at what point the networks become too bulky
    to be fast - 6-16 may be the limit.
<br><br>

    TODO There is a nice peephole optimization you could make. Consider:
<br><br>

    r.conditionalSwap!("a &lt; b", less, 0, 1, 1, 2)(r);
<br><br>

    which needs to do
<br><br>

    if (r[1] &lt; r[0]) r.swapAt(0, 1);
    if (r[2] &lt; r[1]) r.swapAt(1, 2);
<br><br>

    For types with no elaborate copy/assignment, it's more efficient to use a
    "hole"-based approach - assign the first element to a temporary and then
    consider it a hole that you fill, then leaving another hole:
<br><br>

    if (r[1] &lt; r[0])
    if (r[2] &lt; r[0]) r.swapAt(0, 1, 2);
    else r.swapAt(0, 1);
    else
    if (r[2] &lt; r[1]) r.swapAt(1, 2);
<br><br>

    with swapAt with three argument having this definition:
<br><br>

    auto t = r[a]; r[a] = r[b]; r[b] = r[c]; r[c] = t;
<br><br>

    i.e. create a temporary (which creates a "hole" in the array) then fill it
    leaving another hole etc., until the last hole is filled with the temporary.<br><br>

<dl><dt><big><a name="iota"></a>template <u>iota</u>(size_t from, size_t to) if (from &lt;= to)</big></dt>
<dd>Static Iota.
    TODO Move to Phobos std.range.<br><br>

</dd>
<dt><big><a name="conditionalSwap"></a>void <u>conditionalSwap</u>(alias less = "a &lt; b", Range, indexes...)(Range <i>r</i>) if (isRandomAccessRange!Range &amp;&amp; allSatisfy!(isIntegral, typeof(indexes)) &amp;&amp; indexes.length &amp;&amp; (indexes.length &amp; 1) == 0);
</big></dt>
<dd>Conditionally pairwise sort elements of <pre style="display:inline;" class="d_inline_code">Range</pre> <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> at <pre style="display:inline;" class="d_inline_code">indexes</pre> using
    comparison predicate <pre style="display:inline;" class="d_inline_code">less</pre>.
<br><br>
TODO Perhaps defines as
<br><br>

    template <u>conditionalSwap</u>(indexes...)
    {
       void <u>conditionalSwap</u>(less = "a &lt; b", Range)(Range <i>r</i>)
       {
       }
    }
<br><br>

    instead.<br><br>

</dd>
<dt><big><a name="networkSortMaxLength"></a>enum int <u>networkSortMaxLength</u>;
</big></dt>
<dd>Largest length supported by network sort <pre style="display:inline;" class="d_inline_code">networkSortUpTo</pre>.<br><br>

</dd>
<dt><big><a name="networkSortUpTo"></a>auto <u>networkSortUpTo</u>(uint n, alias less = "a &lt; b", Range)(Range <i>r</i>) if (isRandomAccessRange!Range);
</big></dt>
<dd>Sort at most the first <pre style="display:inline;" class="d_inline_code">n</pre> elements of <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> using comparison <pre style="display:inline;" class="d_inline_code">less</pre> using
    a networking sort.
<br><br>
<b>Note:</b><br>
Sorting networks are not unique, not even optimal solutions.
<br><br>

    See also: http://stackoverflow.com/questions/3903086/standard-sorting-networks-for-small-values-of-n
    See also: http://www.cs.brandeis.edu/~hugues/sorting_networks.html<br><br>

</dd>
<dt><big><a name="networkSortExactly"></a>auto <u>networkSortExactly</u>(uint n, alias less = "a &lt; b", Range)(Range <i>r</i>) if (isRandomAccessRange!Range);
</big></dt>
<dd>Sort range <pre style="display:inline;" class="d_inline_code">x</pre> of length <pre style="display:inline;" class="d_inline_code">n</pre> using a networking sort.<br><br>

</dd>
<dt><big><a name="networkSortExactly.2"></a>auto <u>networkSortExactly</u>(alias less = "a &lt; b", T, size_t n)(ref T[n] <i>x</i>);
</big></dt>
<dd>Sort static array <pre style="display:inline;" class="d_inline_code"><i>x</i></pre> of length <pre style="display:inline;" class="d_inline_code">n</pre> using a networking sort.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font>[4] <i>x</i> = [2, 3, 0, 1];
<font color=blue>const</font> <font color=blue>int</font>[4] y = [0, 1, 2, 3];
<i>x</i>.<u>networkSortExactly</u>;
<font color=blue>assert</font>(<i>x</i>[].equal(y[]));
</pre>
<br><br>
</dd>
<dt><big><a name="hybridSort"></a>auto <u>hybridSort</u>(alias less = "a &lt; b", Range)(Range <i>r</i>) if (isRandomAccessRange!Range);
</big></dt>
<dd>Hybrid sort <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> using <pre style="display:inline;" class="d_inline_code">networkSortUpTo</pre> if length of <pre style="display:inline;" class="d_inline_code"><i>r</i></pre> is less-than-or-equal to
    <pre style="display:inline;" class="d_inline_code">networkSortMaxLength</pre> and <pre style="display:inline;" class="d_inline_code">std.algorithm.sorting.sort</pre> otherwise.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.algorithm.sorting : isSorted;
<font color=blue>import</font> std.algorithm.iteration : permutations;
<font color=blue>import</font> std.range : iota;
<font color=blue>import</font> std.random : randomShuffle, Random;

Random random;

<font color=blue>alias</font> T = <font color=blue>uint</font>;

<font color=blue>const</font> maxFullPermutationTestLength = 8;
<font color=blue>const</font> maxTriedShufflings = 10_000; <font color=green>// maximum number of shufflings to try
</font>
<font color=blue>import</font> std.meta : AliasSeq;
<font color=blue>foreach</font> (less; AliasSeq!(<font color=red>"a &lt; b"</font>, <font color=red>"a &gt; b"</font>))
{
    <font color=blue>foreach</font> (<font color=blue>const</font> n; iota(0, networkSortMaxLength + 1))
    {
        <font color=blue>if</font> (n &gt; maxFullPermutationTestLength) <font color=green>// if number of elements is too large
</font>        {
            <font color=blue>foreach</font> (x; iota(0, maxTriedShufflings))
            {
                <font color=blue>import</font> std.array : array;
                <font color=blue>auto</font> y = iota(0, n).array;
                y.randomShuffle(random);
                y.<u>hybridSort</u>!less;
                <font color=blue>assert</font>(y.isSorted!less);
            }
        }
        <font color=blue>else</font>
        {
            <font color=blue>foreach</font> (x; iota(0, n).permutations)
            {
                <font color=blue>import</font> std.array : array;
                <font color=blue>auto</font> y = x.array;
                y.<u>hybridSort</u>!less;
                <font color=blue>assert</font>(y.isSorted!less);
            }
        }
    }
}
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
